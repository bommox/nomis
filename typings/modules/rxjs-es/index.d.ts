// Generated by typings
// Source: node_modules/rxjs-es/Subject.d.ts
declare module '~rxjs-es/Subject' {
import { Operator } from '~rxjs-es/Operator';
import { Observer } from '~rxjs-es/Observer';
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { ISubscription, Subscription } from '~rxjs-es/Subscription';
/**
 * @class SubjectSubscriber<T>
 */
export class SubjectSubscriber<T> extends Subscriber<T> {
    protected destination: Subject<T>;
    constructor(destination: Subject<T>);
}
/**
 * @class Subject<T>
 */
export class Subject<T> extends Observable<T> implements ISubscription {
    observers: Observer<T>[];
    closed: boolean;
    isStopped: boolean;
    hasError: boolean;
    thrownError: any;
    constructor();
    static create: Function;
    lift<T, R>(operator: Operator<T, R>): Observable<T>;
    next(value?: T): void;
    error(err: any): void;
    complete(): void;
    unsubscribe(): void;
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
    asObservable(): Observable<T>;
}
/**
 * @class AnonymousSubject<T>
 */
export class AnonymousSubject<T> extends Subject<T> {
    protected destination: Observer<T>;
    constructor(destination?: Observer<T>, source?: Observable<T>);
    next(value: T): void;
    error(err: any): void;
    complete(): void;
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
}
}
declare module 'rxjs-es/Subject' {
export * from '~rxjs-es/Subject';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/IfObservable.d.ts
declare module '~rxjs-es/observable/IfObservable' {
import { Observable, SubscribableOrPromise } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { TeardownLogic } from '~rxjs-es/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class IfObservable<T, R> extends Observable<T> {
    private condition;
    private thenSource;
    private elseSource;
    static create<T, R>(condition: () => boolean | void, thenSource?: SubscribableOrPromise<T> | void, elseSource?: SubscribableOrPromise<R> | void): Observable<T | R>;
    constructor(condition: () => boolean | void, thenSource?: SubscribableOrPromise<T> | void, elseSource?: SubscribableOrPromise<R> | void);
    protected _subscribe(subscriber: Subscriber<T | R>): TeardownLogic;
}
}
declare module 'rxjs-es/observable/IfObservable' {
export * from '~rxjs-es/observable/IfObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/ErrorObservable.d.ts
declare module '~rxjs-es/observable/ErrorObservable' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
import { TeardownLogic } from '~rxjs-es/Subscription';
export interface DispatchArg {
    error: any;
    subscriber: any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class ErrorObservable extends Observable<any> {
    error: any;
    private scheduler;
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flattens numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    static create<T>(error: any, scheduler?: Scheduler): ErrorObservable;
    static dispatch(arg: DispatchArg): void;
    constructor(error: any, scheduler?: Scheduler);
    protected _subscribe(subscriber: any): TeardownLogic;
}
}
declare module 'rxjs-es/observable/ErrorObservable' {
export * from '~rxjs-es/observable/ErrorObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/Observable.d.ts
declare module '~rxjs-es/Observable' {
import { PartialObserver } from '~rxjs-es/Observer';
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription, AnonymousSubscription, TeardownLogic } from '~rxjs-es/Subscription';
import { IfObservable } from '~rxjs-es/observable/IfObservable';
import { ErrorObservable } from '~rxjs-es/observable/ErrorObservable';
export interface Subscribable<T> {
    subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (error: any) => void, complete?: () => void): AnonymousSubscription;
}
export type SubscribableOrPromise<T> = Subscribable<T> | Promise<T>;
export type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
export class Observable<T> implements Subscribable<T> {
    _isScalar: boolean;
    protected source: Observable<any>;
    protected operator: Operator<any, T>;
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    constructor(subscribe?: <R>(subscriber: Subscriber<R>) => TeardownLogic);
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    static create: Function;
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    lift<R>(operator: Operator<T, R>): Observable<R>;
    /**
     * Registers handlers for handling emitted values, error and completions from the observable, and
     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
     * @method subscribe
     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled
     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     */
    subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (error: any) => void, complete?: () => void): Subscription;
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void>;
    protected _subscribe(subscriber: Subscriber<any>): TeardownLogic;
    static if: typeof IfObservable.create;
    static throw: typeof ErrorObservable.create;
}
}
declare module 'rxjs-es/Observable' {
export * from '~rxjs-es/Observable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/BoundCallbackObservable.d.ts
declare module '~rxjs-es/observable/BoundCallbackObservable' {
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
import { Scheduler } from '~rxjs-es/Scheduler';
import { AsyncSubject } from '~rxjs-es/AsyncSubject';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class BoundCallbackObservable<T> extends Observable<T> {
    private callbackFunc;
    private selector;
    private args;
    private scheduler;
    subject: AsyncSubject<T>;
    static create<R>(callbackFunc: (callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): () => Observable<R>;
    static create<T, R>(callbackFunc: (v1: T, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T) => Observable<R>;
    static create<T, T2, R>(callbackFunc: (v1: T, v2: T2, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2) => Observable<R>;
    static create<T, T2, T3, R>(callbackFunc: (v1: T, v2: T2, v3: T3, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3) => Observable<R>;
    static create<T, T2, T3, T4, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4) => Observable<R>;
    static create<T, T2, T3, T4, T5, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => Observable<R>;
    static create<T, T2, T3, T4, T5, T6, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => Observable<R>;
    static create<R>(callbackFunc: (callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): () => Observable<R>;
    static create<T, R>(callbackFunc: (v1: T, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T) => Observable<R>;
    static create<T, T2, R>(callbackFunc: (v1: T, v2: T2, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2) => Observable<R>;
    static create<T, T2, T3, R>(callbackFunc: (v1: T, v2: T2, v3: T3, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3) => Observable<R>;
    static create<T, T2, T3, T4, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4) => Observable<R>;
    static create<T, T2, T3, T4, T5, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => Observable<R>;
    static create<T, T2, T3, T4, T5, T6, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => Observable<R>;
    static create<T>(callbackFunc: Function, selector?: void, scheduler?: Scheduler): (...args: any[]) => Observable<T>;
    static create<T>(callbackFunc: Function, selector?: (...args: any[]) => T, scheduler?: Scheduler): (...args: any[]) => Observable<T>;
    constructor(callbackFunc: Function, selector: Function, args: any[], scheduler: Scheduler);
    protected _subscribe(subscriber: Subscriber<T | T[]>): Subscription;
    static dispatch<T>(state: {
        source: BoundCallbackObservable<T>;
        subscriber: Subscriber<T>;
    }): void;
}
}
declare module 'rxjs-es/observable/BoundCallbackObservable' {
export * from '~rxjs-es/observable/BoundCallbackObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/bindCallback.d.ts
declare module '~rxjs-es/observable/bindCallback' {
import { BoundCallbackObservable } from '~rxjs-es/observable/BoundCallbackObservable';
export const bindCallback: typeof BoundCallbackObservable.create;
}
declare module 'rxjs-es/observable/bindCallback' {
export * from '~rxjs-es/observable/bindCallback';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/bindCallback.d.ts
declare module '~rxjs-es/add/observable/bindCallback' {
import { bindCallback as staticBindCallback } from '~rxjs-es/observable/bindCallback';
module '~rxjs-es/Observable' {
    namespace Observable {
        let bindCallback: typeof staticBindCallback;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/BoundNodeCallbackObservable.d.ts
declare module '~rxjs-es/observable/BoundNodeCallbackObservable' {
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
import { Scheduler } from '~rxjs-es/Scheduler';
import { AsyncSubject } from '~rxjs-es/AsyncSubject';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class BoundNodeCallbackObservable<T> extends Observable<T> {
    private callbackFunc;
    private selector;
    private args;
    scheduler: Scheduler;
    subject: AsyncSubject<T>;
    static create<R>(callbackFunc: (callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): () => Observable<R>;
    static create<T, R>(callbackFunc: (v1: T, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T) => Observable<R>;
    static create<T, T2, R>(callbackFunc: (v1: T, v2: T2, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2) => Observable<R>;
    static create<T, T2, T3, R>(callbackFunc: (v1: T, v2: T2, v3: T3, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3) => Observable<R>;
    static create<T, T2, T3, T4, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4) => Observable<R>;
    static create<T, T2, T3, T4, T5, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => Observable<R>;
    static create<T, T2, T3, T4, T5, T6, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => Observable<R>;
    static create<T>(callbackFunc: Function, selector?: void, scheduler?: Scheduler): (...args: any[]) => Observable<T>;
    static create<T>(callbackFunc: Function, selector?: (...args: any[]) => T, scheduler?: Scheduler): (...args: any[]) => Observable<T>;
    constructor(callbackFunc: Function, selector: Function, args: any[], scheduler: Scheduler);
    protected _subscribe(subscriber: Subscriber<T | T[]>): Subscription;
}
}
declare module 'rxjs-es/observable/BoundNodeCallbackObservable' {
export * from '~rxjs-es/observable/BoundNodeCallbackObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/bindNodeCallback.d.ts
declare module '~rxjs-es/observable/bindNodeCallback' {
import { BoundNodeCallbackObservable } from '~rxjs-es/observable/BoundNodeCallbackObservable';
export const bindNodeCallback: typeof BoundNodeCallbackObservable.create;
}
declare module 'rxjs-es/observable/bindNodeCallback' {
export * from '~rxjs-es/observable/bindNodeCallback';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/bindNodeCallback.d.ts
declare module '~rxjs-es/add/observable/bindNodeCallback' {
import { bindNodeCallback as staticBindNodeCallback } from '~rxjs-es/observable/bindNodeCallback';
module '~rxjs-es/Observable' {
    namespace Observable {
        let bindNodeCallback: typeof staticBindNodeCallback;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/combineLatest.d.ts
declare module '~rxjs-es/observable/combineLatest' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
export function combineLatest<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<[T, T2]>;
export function combineLatest<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<[T, T2, T3]>;
export function combineLatest<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<[T, T2, T3, T4]>;
export function combineLatest<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<[T, T2, T3, T4, T5]>;
export function combineLatest<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<[T, T2, T3, T4, T5, T6]>;
export function combineLatest<T, R>(v1: ObservableInput<T>, project: (v1: T) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatest<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatest<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatest<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatest<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatest<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatest<T>(array: ObservableInput<T>[], scheduler?: Scheduler): Observable<T[]>;
export function combineLatest<R>(array: ObservableInput<any>[], scheduler?: Scheduler): Observable<R>;
export function combineLatest<T, R>(array: ObservableInput<T>[], project: (...values: Array<T>) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatest<R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatest<T>(...observables: Array<ObservableInput<T> | Scheduler>): Observable<T[]>;
export function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R) | Scheduler>): Observable<R>;
export function combineLatest<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | Scheduler>): Observable<R>;
}
declare module 'rxjs-es/observable/combineLatest' {
export * from '~rxjs-es/observable/combineLatest';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/combineLatest.d.ts
declare module '~rxjs-es/add/observable/combineLatest' {
import { combineLatest as combineLatestStatic } from '~rxjs-es/observable/combineLatest';
module '~rxjs-es/Observable' {
    namespace Observable {
        let combineLatest: typeof combineLatestStatic;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/concat.d.ts
declare module '~rxjs-es/observable/concat' {
import { concatStatic } from '~rxjs-es/operator/concat';
export const concat: typeof concatStatic;
}
declare module 'rxjs-es/observable/concat' {
export * from '~rxjs-es/observable/concat';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/concat.d.ts
declare module '~rxjs-es/add/observable/concat' {
import { concat as concatStatic } from '~rxjs-es/observable/concat';
module '~rxjs-es/Observable' {
    namespace Observable {
        let concat: typeof concatStatic;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/DeferObservable.d.ts
declare module '~rxjs-es/observable/DeferObservable' {
import { Observable, SubscribableOrPromise } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class DeferObservable<T> extends Observable<T> {
    private observableFactory;
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * @see {@link create}
     *
     * @param {function(): Observable|Promise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    static create<T>(observableFactory: () => SubscribableOrPromise<T> | void): Observable<T>;
    constructor(observableFactory: () => SubscribableOrPromise<T> | void);
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
}
}
declare module 'rxjs-es/observable/DeferObservable' {
export * from '~rxjs-es/observable/DeferObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/defer.d.ts
declare module '~rxjs-es/observable/defer' {
import { DeferObservable } from '~rxjs-es/observable/DeferObservable';
export const defer: typeof DeferObservable.create;
}
declare module 'rxjs-es/observable/defer' {
export * from '~rxjs-es/observable/defer';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/defer.d.ts
declare module '~rxjs-es/add/observable/defer' {
import { defer as staticDefer } from '~rxjs-es/observable/defer';
module '~rxjs-es/Observable' {
    namespace Observable {
        let defer: typeof staticDefer;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/EmptyObservable.d.ts
declare module '~rxjs-es/observable/EmptyObservable' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Observable } from '~rxjs-es/Observable';
import { TeardownLogic } from '~rxjs-es/Subscription';
export interface DispatchArg<T> {
    subscriber: Subscriber<T>;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class EmptyObservable<T> extends Observable<T> {
    private scheduler;
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    static create<T>(scheduler?: Scheduler): Observable<T>;
    static dispatch<T>(arg: DispatchArg<T>): void;
    constructor(scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
}
}
declare module 'rxjs-es/observable/EmptyObservable' {
export * from '~rxjs-es/observable/EmptyObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/empty.d.ts
declare module '~rxjs-es/observable/empty' {
import { EmptyObservable } from '~rxjs-es/observable/EmptyObservable';
export const empty: typeof EmptyObservable.create;
}
declare module 'rxjs-es/observable/empty' {
export * from '~rxjs-es/observable/empty';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/empty.d.ts
declare module '~rxjs-es/add/observable/empty' {
import { empty as staticEmpty } from '~rxjs-es/observable/empty';
module '~rxjs-es/Observable' {
    namespace Observable {
        let empty: typeof staticEmpty;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/ForkJoinObservable.d.ts
declare module '~rxjs-es/observable/ForkJoinObservable' {
import { Observable, SubscribableOrPromise } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class ForkJoinObservable<T> extends Observable<T> {
    private sources;
    private resultSelector;
    constructor(sources: Array<SubscribableOrPromise<any>>, resultSelector?: (...values: Array<any>) => T);
    static create<T, T2>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>): Observable<[T, T2]>;
    static create<T, T2, T3>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>): Observable<[T, T2, T3]>;
    static create<T, T2, T3, T4>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>): Observable<[T, T2, T3, T4]>;
    static create<T, T2, T3, T4, T5>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, v5: SubscribableOrPromise<T5>): Observable<[T, T2, T3, T4, T5]>;
    static create<T, T2, T3, T4, T5, T6>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, v5: SubscribableOrPromise<T5>, v6: SubscribableOrPromise<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
    static create<T, T2, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, project: (v1: T, v2: T2) => R): Observable<R>;
    static create<T, T2, T3, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
    static create<T, T2, T3, T4, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
    static create<T, T2, T3, T4, T5, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, v5: SubscribableOrPromise<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
    static create<T, T2, T3, T4, T5, T6, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, v5: SubscribableOrPromise<T5>, v6: SubscribableOrPromise<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
    static create<T>(sources: SubscribableOrPromise<T>[]): Observable<T[]>;
    static create<R>(sources: SubscribableOrPromise<any>[]): Observable<R>;
    static create<T, R>(sources: SubscribableOrPromise<T>[], project: (...values: Array<T>) => R): Observable<R>;
    static create<R>(sources: SubscribableOrPromise<any>[], project: (...values: Array<any>) => R): Observable<R>;
    static create<T>(...sources: SubscribableOrPromise<T>[]): Observable<T[]>;
    static create<R>(...sources: SubscribableOrPromise<any>[]): Observable<R>;
    protected _subscribe(subscriber: Subscriber<any>): Subscription;
}
}
declare module 'rxjs-es/observable/ForkJoinObservable' {
export * from '~rxjs-es/observable/ForkJoinObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/forkJoin.d.ts
declare module '~rxjs-es/observable/forkJoin' {
import { ForkJoinObservable } from '~rxjs-es/observable/ForkJoinObservable';
export const forkJoin: typeof ForkJoinObservable.create;
}
declare module 'rxjs-es/observable/forkJoin' {
export * from '~rxjs-es/observable/forkJoin';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/forkJoin.d.ts
declare module '~rxjs-es/add/observable/forkJoin' {
import { forkJoin as staticForkJoin } from '~rxjs-es/observable/forkJoin';
module '~rxjs-es/Observable' {
    namespace Observable {
        let forkJoin: typeof staticForkJoin;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/FromObservable.d.ts
declare module '~rxjs-es/observable/FromObservable' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable, ObservableInput } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class FromObservable<T> extends Observable<T> {
    private ish;
    private scheduler;
    constructor(ish: ObservableInput<T>, scheduler?: Scheduler);
    static create<T>(ish: ObservableInput<T>, scheduler?: Scheduler): Observable<T>;
    static create<T, R>(ish: ArrayLike<T>, scheduler?: Scheduler): Observable<R>;
    protected _subscribe(subscriber: Subscriber<T>): any;
}
}
declare module 'rxjs-es/observable/FromObservable' {
export * from '~rxjs-es/observable/FromObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/from.d.ts
declare module '~rxjs-es/observable/from' {
import { FromObservable } from '~rxjs-es/observable/FromObservable';
export const from: typeof FromObservable.create;
}
declare module 'rxjs-es/observable/from' {
export * from '~rxjs-es/observable/from';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/from.d.ts
declare module '~rxjs-es/add/observable/from' {
import { from as staticFrom } from '~rxjs-es/observable/from';
module '~rxjs-es/Observable' {
    namespace Observable {
        let from: typeof staticFrom;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/FromEventObservable.d.ts
declare module '~rxjs-es/observable/FromEventObservable' {
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
export type NodeStyleEventEmmitter = {
    addListener: (eventName: string, handler: Function) => void;
    removeListener: (eventName: string, handler: Function) => void;
};
export type JQueryStyleEventEmitter = {
    on: (eventName: string, handler: Function) => void;
    off: (eventName: string, handler: Function) => void;
};
export type EventTargetLike = EventTarget | NodeStyleEventEmmitter | JQueryStyleEventEmitter | NodeList | HTMLCollection;
export type EventListenerOptions = {
    capture?: boolean;
    passive?: boolean;
    once?: boolean;
} | boolean;
export type SelectorMethodSignature<T> = (...args: Array<any>) => T;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class FromEventObservable<T, R> extends Observable<T> {
    private sourceObj;
    private eventName;
    private selector;
    private options;
    static create<T>(target: EventTargetLike, eventName: string): Observable<T>;
    static create<T>(target: EventTargetLike, eventName: string, selector: SelectorMethodSignature<T>): Observable<T>;
    static create<T>(target: EventTargetLike, eventName: string, options: EventListenerOptions): Observable<T>;
    static create<T>(target: EventTargetLike, eventName: string, options: EventListenerOptions, selector: SelectorMethodSignature<T>): Observable<T>;
    constructor(sourceObj: EventTargetLike, eventName: string, selector?: SelectorMethodSignature<T>, options?: EventListenerOptions);
    private static setupSubscription<T>(sourceObj, eventName, handler, subscriber, options?);
    protected _subscribe(subscriber: Subscriber<T>): void;
}
}
declare module 'rxjs-es/observable/FromEventObservable' {
export * from '~rxjs-es/observable/FromEventObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/fromEvent.d.ts
declare module '~rxjs-es/observable/fromEvent' {
import { FromEventObservable } from '~rxjs-es/observable/FromEventObservable';
export const fromEvent: typeof FromEventObservable.create;
}
declare module 'rxjs-es/observable/fromEvent' {
export * from '~rxjs-es/observable/fromEvent';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/fromEvent.d.ts
declare module '~rxjs-es/add/observable/fromEvent' {
import { fromEvent as staticFromEvent } from '~rxjs-es/observable/fromEvent';
module '~rxjs-es/Observable' {
    namespace Observable {
        let fromEvent: typeof staticFromEvent;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/FromEventPatternObservable.d.ts
declare module '~rxjs-es/observable/FromEventPatternObservable' {
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class FromEventPatternObservable<T, R> extends Observable<T> {
    private addHandler;
    private removeHandler;
    private selector;
    /**
     * Creates an Observable from an API based on addHandler/removeHandler
     * functions.
     *
     * <span class="informal">Converts any addHandler/removeHandler API to an
     * Observable.</span>
     *
     * <img src="./img/fromEventPattern.png" width="100%">
     *
     * Creates an Observable by using the `addHandler` and `removeHandler`
     * functions to add and remove the handlers, with an optional selector
     * function to project the event arguments to a result. The `addHandler` is
     * called when the output Observable is subscribed, and `removeHandler` is
     * called when the Subscription is unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * function addClickHandler(handler) {
     *   document.addEventListener('click', handler);
     * }
     *
     * function removeClickHandler(handler) {
     *   document.removeEventListener('click', handler);
     * }
     *
     * var clicks = Rx.Observable.fromEventPattern(
     *   addClickHandler,
     *   removeClickHandler
     * );
     * clicks.subscribe(x => console.log(x));
     *
     * @see {@link from}
     * @see {@link fromEvent}
     *
     * @param {function(handler: Function): any} addHandler A function that takes
     * a `handler` function as argument and attaches it somehow to the actual
     * source of events.
     * @param {function(handler: Function): void} removeHandler A function that
     * takes a `handler` function as argument and removes it in case it was
     * previously attached using `addHandler`.
     * @param {function(...args: any): T} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEventPattern
     * @owner Observable
     */
    static create<T>(addHandler: (handler: Function) => any, removeHandler: (handler: Function) => void, selector?: (...args: Array<any>) => T): FromEventPatternObservable<T, {}>;
    constructor(addHandler: (handler: Function) => any, removeHandler: (handler: Function) => void, selector?: (...args: Array<any>) => T);
    protected _subscribe(subscriber: Subscriber<T>): void;
    private _callSelector(subscriber, args);
    private _callAddHandler(handler, errorSubscriber);
}
}
declare module 'rxjs-es/observable/FromEventPatternObservable' {
export * from '~rxjs-es/observable/FromEventPatternObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/fromEventPattern.d.ts
declare module '~rxjs-es/observable/fromEventPattern' {
import { FromEventPatternObservable } from '~rxjs-es/observable/FromEventPatternObservable';
export const fromEventPattern: typeof FromEventPatternObservable.create;
}
declare module 'rxjs-es/observable/fromEventPattern' {
export * from '~rxjs-es/observable/fromEventPattern';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/fromEventPattern.d.ts
declare module '~rxjs-es/add/observable/fromEventPattern' {
import { fromEventPattern as staticFromEventPattern } from '~rxjs-es/observable/fromEventPattern';
module '~rxjs-es/Observable' {
    namespace Observable {
        let fromEventPattern: typeof staticFromEventPattern;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/PromiseObservable.d.ts
declare module '~rxjs-es/observable/PromiseObservable' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { TeardownLogic } from '~rxjs-es/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class PromiseObservable<T> extends Observable<T> {
    private promise;
    private scheduler;
    value: T;
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {Promise<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional Scheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    static create<T>(promise: Promise<T>, scheduler?: Scheduler): Observable<T>;
    constructor(promise: Promise<T>, scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
}
}
declare module 'rxjs-es/observable/PromiseObservable' {
export * from '~rxjs-es/observable/PromiseObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/fromPromise.d.ts
declare module '~rxjs-es/observable/fromPromise' {
import { PromiseObservable } from '~rxjs-es/observable/PromiseObservable';
export const fromPromise: typeof PromiseObservable.create;
}
declare module 'rxjs-es/observable/fromPromise' {
export * from '~rxjs-es/observable/fromPromise';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/fromPromise.d.ts
declare module '~rxjs-es/add/observable/fromPromise' {
import { fromPromise as staticFromPromise } from '~rxjs-es/observable/fromPromise';
module '~rxjs-es/Observable' {
    namespace Observable {
        let fromPromise: typeof staticFromPromise;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/GenerateObservable.d.ts
declare module '~rxjs-es/observable/GenerateObservable' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
export type ConditionFunc<S> = (state: S) => boolean;
export type IterateFunc<S> = (state: S) => S;
export type ResultFunc<S, T> = (state: S) => T;
export interface GenerateBaseOptions<S> {
    /**
     * Inital state.
    */
    initialState: S;
    /**
     * Condition function that accepts state and returns boolean.
     * When it returns false, the generator stops.
     * If not specified, a generator never stops.
    */
    condition?: ConditionFunc<S>;
    /**
     * Iterate function that accepts state and returns new state.
     */
    iterate: IterateFunc<S>;
    /**
     * Scheduler to use for generation process.
     * By default, a generator starts immediately.
    */
    scheduler?: Scheduler;
}
export interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {
    /**
     * Result selection function that accepts state and returns a value to emit.
     */
    resultSelector: ResultFunc<S, T>;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class GenerateObservable<T, S> extends Observable<T> {
    private initialState;
    private condition;
    private iterate;
    private resultSelector;
    private scheduler;
    constructor(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, resultSelector: ResultFunc<S, T>, scheduler?: Scheduler);
    /**
     * Generates an observable sequence by running a state-driven loop
     * producing the sequence's elements, using the specified scheduler
     * to send out observer messages.
     *
     * <img src="./img/generate.png" width="100%">
     *
     * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
     * var res = Rx.Observable.generate(0, x => x < 10, x => x + 1, x => x);
     *
     * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>
     * var res = Rx.Observable.generate(1, x => x < 5, x => x * 2, x => x + 1, Rx.Scheduler.asap);
     *
     * @see {@link from}
     * @see {@link create}
     *
     * @param {S} initialState Initial state.
     * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).
     * @param {function (state: S): S} iterate Iteration step function.
     * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence.
     * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emit immediately.
     * @returns {Observable<T>} The generated sequence.
     */
    static create<T, S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, resultSelector: ResultFunc<S, T>, scheduler?: Scheduler): Observable<T>;
    /**
     * Generates an observable sequence by running a state-driven loop
     * producing the sequence's elements, using the specified scheduler
     * to send out observer messages.
     * The overload uses state as an emitted value.
     *
     * <img src="./img/generate.png" width="100%">
     *
     * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
     * var res = Rx.Observable.generate(0, x => x < 10, x => x + 1);
     *
     * @example <caption>Using asap scheduler, produces sequence of 1, 2, 4, then completes.</caption>
     * var res = Rx.Observable.generate(1, x => x < 5, x => x * 2, Rx.Scheduler.asap);
     *
     * @see {@link from}
     * @see {@link create}
     *
     * @param {S} initialState Initial state.
     * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).
     * @param {function (state: S): S} iterate Iteration step function.
     * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emit immediately.
     * @returns {Observable<S>} The generated sequence.
     */
    static create<S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, scheduler?: Scheduler): Observable<S>;
    /**
     * Generates an observable sequence by running a state-driven loop
     * producing the sequence's elements, using the specified scheduler
     * to send out observer messages.
     * The overload accepts options object that might contain inital state, iterate,
     * condition and scheduler.
     *
     * <img src="./img/generate.png" width="100%">
     *
     * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
     * var res = Rx.Observable.generate({
     *   initialState: 0,
     *   condition: x => x < 10,
     *   iterate: x => x + 1
     * });
     *
     * @see {@link from}
     * @see {@link create}
     *
     * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.
     * @returns {Observable<S>} The generated sequence.
     */
    static create<S>(options: GenerateBaseOptions<S>): Observable<S>;
    /**
     * Generates an observable sequence by running a state-driven loop
     * producing the sequence's elements, using the specified scheduler
     * to send out observer messages.
     * The overload accepts options object that might contain inital state, iterate,
     * condition, result selector and scheduler.
     *
     * <img src="./img/generate.png" width="100%">
     *
     * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
     * var res = Rx.Observable.generate({
     *   initialState: 0,
     *   condition: x => x < 10,
     *   iterate: x => x + 1,
     *   resultSelector: x => x
     * });
     *
     * @see {@link from}
     * @see {@link create}
     *
     * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.
     * @returns {Observable<T>} The generated sequence.
     */
    static create<T, S>(options: GenerateOptions<T, S>): Observable<T>;
    protected _subscribe(subscriber: Subscriber<any>): Subscription | Function | void;
    private static dispatch<T, S>(state);
}
}
declare module 'rxjs-es/observable/GenerateObservable' {
export * from '~rxjs-es/observable/GenerateObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/generate.d.ts
declare module '~rxjs-es/add/observable/generate' {
import { GenerateObservable } from '~rxjs-es/observable/GenerateObservable';
module '~rxjs-es/Observable' {
    namespace Observable {
        let generate: typeof GenerateObservable.create;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/if.d.ts
declare module '~rxjs-es/add/observable/if' {}

// Generated by typings
// Source: node_modules/rxjs-es/observable/IntervalObservable.d.ts
declare module '~rxjs-es/observable/IntervalObservable' {
import { Subscriber } from '~rxjs-es/Subscriber';
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class IntervalObservable extends Observable<number> {
    private period;
    private scheduler;
    /**
     * Creates an Observable that emits sequential numbers every specified
     * interval of time, on a specified Scheduler.
     *
     * <span class="informal">Emits incremental numbers periodically in time.
     * </span>
     *
     * <img src="./img/interval.png" width="100%">
     *
     * `interval` returns an Observable that emits an infinite sequence of
     * ascending integers, with a constant interval of time of your choosing
     * between those emissions. The first emission is not sent immediately, but
     * only after the first period has passed. By default, this operator uses the
     * `async` Scheduler to provide a notion of time, but you may pass any
     * Scheduler to it.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
     * var numbers = Rx.Observable.interval(1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link delay}
     *
     * @param {number} [period=0] The interval size in milliseconds (by default)
     * or the time unit determined by the scheduler's clock.
     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a sequential number each time
     * interval.
     * @static true
     * @name interval
     * @owner Observable
     */
    static create(period?: number, scheduler?: Scheduler): Observable<number>;
    static dispatch(state: any): void;
    constructor(period?: number, scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<number>): void;
}
}
declare module 'rxjs-es/observable/IntervalObservable' {
export * from '~rxjs-es/observable/IntervalObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/interval.d.ts
declare module '~rxjs-es/observable/interval' {
import { IntervalObservable } from '~rxjs-es/observable/IntervalObservable';
export const interval: typeof IntervalObservable.create;
}
declare module 'rxjs-es/observable/interval' {
export * from '~rxjs-es/observable/interval';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/interval.d.ts
declare module '~rxjs-es/add/observable/interval' {
import { interval as staticInterval } from '~rxjs-es/observable/interval';
module '~rxjs-es/Observable' {
    namespace Observable {
        let interval: typeof staticInterval;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/merge.d.ts
declare module '~rxjs-es/observable/merge' {
import { mergeStatic } from '~rxjs-es/operator/merge';
export const merge: typeof mergeStatic;
}
declare module 'rxjs-es/observable/merge' {
export * from '~rxjs-es/observable/merge';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/merge.d.ts
declare module '~rxjs-es/add/observable/merge' {
import { merge as mergeStatic } from '~rxjs-es/observable/merge';
module '~rxjs-es/Observable' {
    namespace Observable {
        let merge: typeof mergeStatic;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/OuterSubscriber.d.ts
declare module '~rxjs-es/OuterSubscriber' {
import { Subscriber } from '~rxjs-es/Subscriber';
import { InnerSubscriber } from '~rxjs-es/InnerSubscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class OuterSubscriber<T, R> extends Subscriber<T> {
    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
    notifyError(error: any, innerSub: InnerSubscriber<T, R>): void;
    notifyComplete(innerSub: InnerSubscriber<T, R>): void;
}
}
declare module 'rxjs-es/OuterSubscriber' {
export * from '~rxjs-es/OuterSubscriber';
}

// Generated by typings
// Source: node_modules/rxjs-es/InnerSubscriber.d.ts
declare module '~rxjs-es/InnerSubscriber' {
import { Subscriber } from '~rxjs-es/Subscriber';
import { OuterSubscriber } from '~rxjs-es/OuterSubscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class InnerSubscriber<T, R> extends Subscriber<R> {
    private parent;
    private outerValue;
    private outerIndex;
    private index;
    constructor(parent: OuterSubscriber<T, R>, outerValue: T, outerIndex: number);
    protected _next(value: R): void;
    protected _error(error: any): void;
    protected _complete(): void;
}
}
declare module 'rxjs-es/InnerSubscriber' {
export * from '~rxjs-es/InnerSubscriber';
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/race.d.ts
declare module '~rxjs-es/operator/race' {
import { Observable } from '~rxjs-es/Observable';
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
import { TeardownLogic } from '~rxjs-es/Subscription';
import { OuterSubscriber } from '~rxjs-es/OuterSubscriber';
import { InnerSubscriber } from '~rxjs-es/InnerSubscriber';
/**
 * Returns an Observable that mirrors the first source Observable to emit an item
 * from the combination of this Observable and supplied Observables
 * @param {...Observables} ...observables sources used to race for which Observable emits first.
 * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.
 * @method race
 * @owner Observable
 */
export function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;
export interface RaceSignature<T> {
    (...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;
    <R>(...observables: Array<Observable<any> | Array<Observable<T>>>): Observable<R>;
}
/**
 * Returns an Observable that mirrors the first source Observable to emit an item.
 * @param {...Observables} ...observables sources used to race for which Observable emits first.
 * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.
 * @static true
 * @name race
 * @owner Observable
 */
export function raceStatic<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;
export class RaceOperator<T> implements Operator<T, T> {
    call(subscriber: Subscriber<T>, source: any): TeardownLogic;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class RaceSubscriber<T> extends OuterSubscriber<T, T> {
    private hasFirst;
    private observables;
    private subscriptions;
    constructor(destination: Subscriber<T>);
    protected _next(observable: any): void;
    protected _complete(): void;
    notifyNext(outerValue: T, innerValue: T, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, T>): void;
}
}
declare module 'rxjs-es/operator/race' {
export * from '~rxjs-es/operator/race';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/race.d.ts
declare module '~rxjs-es/add/observable/race' {
import { raceStatic } from '~rxjs-es/operator/race';
module '~rxjs-es/Observable' {
    namespace Observable {
        let race: typeof raceStatic;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/NeverObservable.d.ts
declare module '~rxjs-es/observable/NeverObservable' {
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class NeverObservable<T> extends Observable<T> {
    /**
     * Creates an Observable that emits no items to the Observer.
     *
     * <span class="informal">An Observable that never emits anything.</span>
     *
     * <img src="./img/never.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that emits
     * neither values nor errors nor the completion notification. It can be used
     * for testing purposes or for composing with other Observables. Please not
     * that by never emitting a complete notification, this Observable keeps the
     * subscription from being disposed automatically. Subscriptions need to be
     * manually disposed.
     *
     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
     * function info() {
     *   console.log('Will not be called');
     * }
     * var result = Rx.Observable.never().startWith(7);
     * result.subscribe(x => console.log(x), info, info);
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link of}
     * @see {@link throw}
     *
     * @return {Observable} A "never" Observable: never emits anything.
     * @static true
     * @name never
     * @owner Observable
     */
    static create<T>(): NeverObservable<T>;
    constructor();
    protected _subscribe(subscriber: Subscriber<T>): void;
}
}
declare module 'rxjs-es/observable/NeverObservable' {
export * from '~rxjs-es/observable/NeverObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/never.d.ts
declare module '~rxjs-es/observable/never' {
import { NeverObservable } from '~rxjs-es/observable/NeverObservable';
export const never: typeof NeverObservable.create;
}
declare module 'rxjs-es/observable/never' {
export * from '~rxjs-es/observable/never';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/never.d.ts
declare module '~rxjs-es/add/observable/never' {
import { never as staticNever } from '~rxjs-es/observable/never';
module '~rxjs-es/Observable' {
    namespace Observable {
        let never: typeof staticNever;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/ArrayObservable.d.ts
declare module '~rxjs-es/observable/ArrayObservable' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { TeardownLogic } from '~rxjs-es/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class ArrayObservable<T> extends Observable<T> {
    private array;
    private scheduler;
    static create<T>(array: T[], scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, item3: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(...array: Array<T | Scheduler>): Observable<T>;
    static dispatch(state: any): void;
    value: any;
    constructor(array: T[], scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
}
}
declare module 'rxjs-es/observable/ArrayObservable' {
export * from '~rxjs-es/observable/ArrayObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/of.d.ts
declare module '~rxjs-es/observable/of' {
import { ArrayObservable } from '~rxjs-es/observable/ArrayObservable';
export const of: typeof ArrayObservable.of;
}
declare module 'rxjs-es/observable/of' {
export * from '~rxjs-es/observable/of';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/of.d.ts
declare module '~rxjs-es/add/observable/of' {
import { of as staticOf } from '~rxjs-es/observable/of';
module '~rxjs-es/Observable' {
    namespace Observable {
        let of: typeof staticOf;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/onErrorResumeNext.d.ts
declare module '~rxjs-es/operator/onErrorResumeNext' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
export function onErrorResumeNext<T, R>(...nextSources: Array<ObservableInput<any> | Array<ObservableInput<any>> | ((...values: Array<any>) => R)>): Observable<R>;
export interface OnErrorResumeNextSignature<T> {
    <R>(v: ObservableInput<R>): Observable<R>;
    <T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;
    <T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;
    <T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;
    <T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;
    <R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
    <R>(array: ObservableInput<any>[]): Observable<R>;
}
export function onErrorResumeNextStatic<R>(v: ObservableInput<R>): Observable<R>;
export function onErrorResumeNextStatic<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;
export function onErrorResumeNextStatic<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;
export function onErrorResumeNextStatic<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;
export function onErrorResumeNextStatic<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;
export function onErrorResumeNextStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
export function onErrorResumeNextStatic<R>(array: ObservableInput<any>[]): Observable<R>;
}
declare module 'rxjs-es/operator/onErrorResumeNext' {
export * from '~rxjs-es/operator/onErrorResumeNext';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/onErrorResumeNext.d.ts
declare module '~rxjs-es/add/observable/onErrorResumeNext' {
import { onErrorResumeNextStatic } from '~rxjs-es/operator/onErrorResumeNext';
module '~rxjs-es/Observable' {
    namespace Observable {
        let onErrorResumeNext: typeof onErrorResumeNextStatic;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/PairsObservable.d.ts
declare module '~rxjs-es/observable/PairsObservable' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { TeardownLogic } from '~rxjs-es/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class PairsObservable<T> extends Observable<Array<string | T>> {
    private obj;
    private scheduler;
    private keys;
    /**
     * Convert an object into an observable sequence of [key, value] pairs
     * using an optional Scheduler to enumerate the object.
     *
     * @example <caption>Converts a javascript object to an Observable</caption>
     * var obj = {
     *   foo: 42,
     *   bar: 56,
     *   baz: 78
     * };
     *
     * var source = Rx.Observable.pairs(obj);
     *
     * var subscription = source.subscribe(
     *   function (x) {
     *     console.log('Next: %s', x);
     *   },
     *   function (err) {
     *     console.log('Error: %s', err);
     *   },
     *   function () {
     *     console.log('Completed');
     *   });
     *
     * @param {Object} obj The object to inspect and turn into an
     * Observable sequence.
     * @param {Scheduler} [scheduler] An optional Scheduler to run the
     * enumeration of the input sequence on.
     * @returns {(Observable<Array<string | T>>)} An observable sequence of
     * [key, value] pairs from the object.
     */
    static create<T>(obj: Object, scheduler?: Scheduler): Observable<Array<string | T>>;
    constructor(obj: Object, scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<Array<string | T>>): TeardownLogic;
}
}
declare module 'rxjs-es/observable/PairsObservable' {
export * from '~rxjs-es/observable/PairsObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/pairs.d.ts
declare module '~rxjs-es/observable/pairs' {
import { PairsObservable } from '~rxjs-es/observable/PairsObservable';
export const pairs: typeof PairsObservable.create;
}
declare module 'rxjs-es/observable/pairs' {
export * from '~rxjs-es/observable/pairs';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/pairs.d.ts
declare module '~rxjs-es/add/observable/pairs' {
import { pairs as staticPairs } from '~rxjs-es/observable/pairs';
module '~rxjs-es/Observable' {
    namespace Observable {
        let pairs: typeof staticPairs;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/RangeObservable.d.ts
declare module '~rxjs-es/observable/RangeObservable' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
import { TeardownLogic } from '~rxjs-es/Subscription';
import { Subscriber } from '~rxjs-es/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class RangeObservable extends Observable<number> {
    /**
     * Creates an Observable that emits a sequence of numbers within a specified
     * range.
     *
     * <span class="informal">Emits a sequence of numbers in a range.</span>
     *
     * <img src="./img/range.png" width="100%">
     *
     * `range` operator emits a range of sequential integers, in order, where you
     * select the `start` of the range and its `length`. By default, uses no
     * Scheduler and just delivers the notifications synchronously, but may use
     * an optional Scheduler to regulate those deliveries.
     *
     * @example <caption>Emits the numbers 1 to 10</caption>
     * var numbers = Rx.Observable.range(1, 10);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link interval}
     *
     * @param {number} [start=0] The value of the first integer in the sequence.
     * @param {number} [count=0] The number of sequential integers to generate.
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emissions of the notifications.
     * @return {Observable} An Observable of numbers that emits a finite range of
     * sequential integers.
     * @static true
     * @name range
     * @owner Observable
     */
    static create(start?: number, count?: number, scheduler?: Scheduler): Observable<number>;
    static dispatch(state: any): void;
    private start;
    private _count;
    private scheduler;
    constructor(start: number, count: number, scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<number>): TeardownLogic;
}
}
declare module 'rxjs-es/observable/RangeObservable' {
export * from '~rxjs-es/observable/RangeObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/range.d.ts
declare module '~rxjs-es/observable/range' {
import { RangeObservable } from '~rxjs-es/observable/RangeObservable';
export const range: typeof RangeObservable.create;
}
declare module 'rxjs-es/observable/range' {
export * from '~rxjs-es/observable/range';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/range.d.ts
declare module '~rxjs-es/add/observable/range' {
import { range as staticRange } from '~rxjs-es/observable/range';
module '~rxjs-es/Observable' {
    namespace Observable {
        let range: typeof staticRange;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/UsingObservable.d.ts
declare module '~rxjs-es/observable/UsingObservable' {
import { Observable, SubscribableOrPromise } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { AnonymousSubscription, TeardownLogic } from '~rxjs-es/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class UsingObservable<T> extends Observable<T> {
    private resourceFactory;
    private observableFactory;
    static create<T>(resourceFactory: () => AnonymousSubscription | void, observableFactory: (resource: AnonymousSubscription) => SubscribableOrPromise<T> | void): Observable<T>;
    constructor(resourceFactory: () => AnonymousSubscription | void, observableFactory: (resource: AnonymousSubscription) => SubscribableOrPromise<T> | void);
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
}
}
declare module 'rxjs-es/observable/UsingObservable' {
export * from '~rxjs-es/observable/UsingObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/using.d.ts
declare module '~rxjs-es/observable/using' {
import { UsingObservable } from '~rxjs-es/observable/UsingObservable';
export const using: typeof UsingObservable.create;
}
declare module 'rxjs-es/observable/using' {
export * from '~rxjs-es/observable/using';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/using.d.ts
declare module '~rxjs-es/add/observable/using' {
import { using as staticUsing } from '~rxjs-es/observable/using';
module '~rxjs-es/Observable' {
    namespace Observable {
        let using: typeof staticUsing;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/throw.d.ts
declare module '~rxjs-es/add/observable/throw' {}

// Generated by typings
// Source: node_modules/rxjs-es/observable/TimerObservable.d.ts
declare module '~rxjs-es/observable/TimerObservable' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
import { TeardownLogic } from '~rxjs-es/Subscription';
import { Subscriber } from '~rxjs-es/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class TimerObservable extends Observable<number> {
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` Scheduler to provide a notion of time, but you
     * may pass any Scheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    static create(initialDelay?: number | Date, period?: number | Scheduler, scheduler?: Scheduler): Observable<number>;
    static dispatch(state: any): any;
    private period;
    private dueTime;
    private scheduler;
    constructor(dueTime?: number | Date, period?: number | Scheduler, scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<number>): TeardownLogic;
}
}
declare module 'rxjs-es/observable/TimerObservable' {
export * from '~rxjs-es/observable/TimerObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/timer.d.ts
declare module '~rxjs-es/observable/timer' {
import { TimerObservable } from '~rxjs-es/observable/TimerObservable';
export const timer: typeof TimerObservable.create;
}
declare module 'rxjs-es/observable/timer' {
export * from '~rxjs-es/observable/timer';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/timer.d.ts
declare module '~rxjs-es/add/observable/timer' {
import { timer as staticTimer } from '~rxjs-es/observable/timer';
module '~rxjs-es/Observable' {
    namespace Observable {
        let timer: typeof staticTimer;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/zip.d.ts
declare module '~rxjs-es/observable/zip' {
import { zipStatic } from '~rxjs-es/operator/zip';
export const zip: typeof zipStatic;
}
declare module 'rxjs-es/observable/zip' {
export * from '~rxjs-es/observable/zip';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/zip.d.ts
declare module '~rxjs-es/add/observable/zip' {
import { zip as zipStatic } from '~rxjs-es/observable/zip';
module '~rxjs-es/Observable' {
    namespace Observable {
        let zip: typeof zipStatic;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/dom/ajax.d.ts
declare module '~rxjs-es/add/observable/dom/ajax' {
import { AjaxCreationMethod } from '~rxjs-es/observable/dom/AjaxObservable';
module '~rxjs-es/Observable' {
    namespace Observable {
        let ajax: AjaxCreationMethod;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/dom/WebSocketSubject.d.ts
declare module '~rxjs-es/observable/dom/WebSocketSubject' {
import { AnonymousSubject } from '~rxjs-es/Subject';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Observable } from '~rxjs-es/Observable';
import { Subscription } from '~rxjs-es/Subscription';
import { Operator } from '~rxjs-es/Operator';
import { Observer, NextObserver } from '~rxjs-es/Observer';
export interface WebSocketSubjectConfig {
    url: string;
    protocol?: string | Array<string>;
    resultSelector?: <T>(e: MessageEvent) => T;
    openObserver?: NextObserver<Event>;
    closeObserver?: NextObserver<CloseEvent>;
    closingObserver?: NextObserver<void>;
    WebSocketCtor?: {
        new (url: string, protocol?: string | Array<string>): WebSocket;
    };
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class WebSocketSubject<T> extends AnonymousSubject<T> {
    url: string;
    protocol: string | Array<string>;
    socket: WebSocket;
    openObserver: NextObserver<Event>;
    closeObserver: NextObserver<CloseEvent>;
    closingObserver: NextObserver<void>;
    WebSocketCtor: {
        new (url: string, protocol?: string | Array<string>): WebSocket;
    };
    private _output;
    resultSelector(e: MessageEvent): any;
    /**
     * @param urlConfigOrSource
     * @return {WebSocketSubject}
     * @static true
     * @name webSocket
     * @owner Observable
     */
    static create<T>(urlConfigOrSource: string | WebSocketSubjectConfig): WebSocketSubject<T>;
    constructor(urlConfigOrSource: string | WebSocketSubjectConfig | Observable<T>, destination?: Observer<T>);
    lift<R>(operator: Operator<T, R>): WebSocketSubject<R>;
    multiplex(subMsg: () => any, unsubMsg: () => any, messageFilter: (value: T) => boolean): Observable<{}>;
    private _connectSocket();
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
    unsubscribe(): void;
}
}
declare module 'rxjs-es/observable/dom/WebSocketSubject' {
export * from '~rxjs-es/observable/dom/WebSocketSubject';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/dom/webSocket.d.ts
declare module '~rxjs-es/observable/dom/webSocket' {
import { WebSocketSubject } from '~rxjs-es/observable/dom/WebSocketSubject';
export const webSocket: typeof WebSocketSubject.create;
}
declare module 'rxjs-es/observable/dom/webSocket' {
export * from '~rxjs-es/observable/dom/webSocket';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/observable/dom/webSocket.d.ts
declare module '~rxjs-es/add/observable/dom/webSocket' {
import { webSocket as staticWebSocket } from '~rxjs-es/observable/dom/webSocket';
module '~rxjs-es/Observable' {
    namespace Observable {
        let webSocket: typeof staticWebSocket;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/buffer.d.ts
declare module '~rxjs-es/operator/buffer' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Buffers the source Observable values until `closingNotifier` emits.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when another Observable emits.</span>
 *
 * <img src="./img/buffer.png" width="100%">
 *
 * Buffers the incoming Observable values until the given `closingNotifier`
 * Observable emits a value, at which point it emits the buffer on the output
 * Observable and starts a new buffer internally, awaiting the next time
 * `closingNotifier` emits.
 *
 * @example <caption>On every click, emit array of most recent interval events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var buffered = interval.buffer(clicks);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link window}
 *
 * @param {Observable<any>} closingNotifier An Observable that signals the
 * buffer to be emitted on the output Observable.
 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
 * values.
 * @method buffer
 * @owner Observable
 */
export function buffer<T>(closingNotifier: Observable<any>): Observable<T[]>;
export interface BufferSignature<T> {
    (closingNotifier: Observable<any>): Observable<T[]>;
}
}
declare module 'rxjs-es/operator/buffer' {
export * from '~rxjs-es/operator/buffer';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/buffer.d.ts
declare module '~rxjs-es/add/operator/buffer' {
import { BufferSignature } from '~rxjs-es/operator/buffer';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        buffer: BufferSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/bufferCount.d.ts
declare module '~rxjs-es/operator/bufferCount' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * <img src="./img/bufferCount.png" width="100%">
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * @example <caption>Emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>On every click, emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2, 1);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link pairwise}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return {Observable<T[]>} An Observable of arrays of buffered values.
 * @method bufferCount
 * @owner Observable
 */
export function bufferCount<T>(bufferSize: number, startBufferEvery?: number): Observable<T[]>;
export interface BufferCountSignature<T> {
    (bufferSize: number, startBufferEvery?: number): Observable<T[]>;
}
}
declare module 'rxjs-es/operator/bufferCount' {
export * from '~rxjs-es/operator/bufferCount';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/bufferCount.d.ts
declare module '~rxjs-es/add/operator/bufferCount' {
import { BufferCountSignature } from '~rxjs-es/operator/bufferCount';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        bufferCount: BufferCountSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/bufferTime.d.ts
declare module '~rxjs-es/operator/bufferTime' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
/**
 * Buffers the source Observable values for a specific time period.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * those arrays periodically in time.</span>
 *
 * <img src="./img/bufferTime.png" width="100%">
 *
 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
 * Unless the optional argument `bufferCreationInterval` is given, it emits and
 * resets the buffer every `bufferTimeSpan` milliseconds. If
 * `bufferCreationInterval` is given, this operator opens the buffer every
 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
 * `maxBufferSize` is specified, the buffer will be closed either after
 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
 *
 * @example <caption>Every second, emit an array of the recent click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(1000);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(2000, 5000);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link windowTime}
 *
 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
 * @param {number} [bufferCreationInterval] The interval at which to start new
 * buffers.
 * @param {number} [maxBufferSize] The maximum buffer size.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine buffer boundaries.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferTime
 * @owner Observable
 */
export function bufferTime<T>(bufferTimeSpan: number): Observable<T[]>;
export interface BufferTimeSignature<T> {
    (bufferTimeSpan: number, scheduler?: Scheduler): Observable<T[]>;
    (bufferTimeSpan: number, bufferCreationInterval: number, scheduler?: Scheduler): Observable<T[]>;
    (bufferTimeSpan: number, bufferCreationInterval: number, maxBufferSize: number, scheduler?: Scheduler): Observable<T[]>;
}
}
declare module 'rxjs-es/operator/bufferTime' {
export * from '~rxjs-es/operator/bufferTime';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/bufferTime.d.ts
declare module '~rxjs-es/add/operator/bufferTime' {
import { BufferTimeSignature } from '~rxjs-es/operator/bufferTime';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        bufferTime: BufferTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/bufferToggle.d.ts
declare module '~rxjs-es/operator/bufferToggle' {
import { Observable, SubscribableOrPromise } from '~rxjs-es/Observable';
/**
 * Buffers the source Observable values starting from an emission from
 * `openings` and ending when the output of `closingSelector` emits.
 *
 * <span class="informal">Collects values from the past as an array. Starts
 * collecting only when `opening` emits, and calls the `closingSelector`
 * function to get an Observable that tells when to close the buffer.</span>
 *
 * <img src="./img/bufferToggle.png" width="100%">
 *
 * Buffers values from the source by opening the buffer via signals from an
 * Observable provided to `openings`, and closing and sending the buffers when
 * a Subscribable or Promise returned by the `closingSelector` function emits.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var buffered = clicks.bufferToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferWhen}
 * @see {@link windowToggle}
 *
 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
 * buffers.
 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
 * which, when it emits, signals that the associated buffer should be emitted
 * and cleared.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferToggle
 * @owner Observable
 */
export function bufferToggle<T, O>(openings: SubscribableOrPromise<O>, closingSelector: (value: O) => SubscribableOrPromise<any>): Observable<T[]>;
export interface BufferToggleSignature<T> {
    <O>(openings: SubscribableOrPromise<O>, closingSelector: (value: O) => SubscribableOrPromise<any>): Observable<T[]>;
}
}
declare module 'rxjs-es/operator/bufferToggle' {
export * from '~rxjs-es/operator/bufferToggle';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/bufferToggle.d.ts
declare module '~rxjs-es/add/operator/bufferToggle' {
import { BufferToggleSignature } from '~rxjs-es/operator/bufferToggle';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        bufferToggle: BufferToggleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/bufferWhen.d.ts
declare module '~rxjs-es/operator/bufferWhen' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Buffers the source Observable values, using a factory function of closing
 * Observables to determine when to close, emit, and reset the buffer.
 *
 * <span class="informal">Collects values from the past as an array. When it
 * starts collecting values, it calls a function that returns an Observable that
 * tells when to close the buffer and restart collecting.</span>
 *
 * <img src="./img/bufferWhen.png" width="100%">
 *
 * Opens a buffer immediately, then closes the buffer when the observable
 * returned by calling `closingSelector` function emits a value. When it closes
 * the buffer, it immediately opens a new buffer and repeats the process.
 *
 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferWhen(() =>
 *   Rx.Observable.interval(1000 + Math.random() * 4000)
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link windowWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals buffer closure.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferWhen
 * @owner Observable
 */
export function bufferWhen<T>(closingSelector: () => Observable<any>): Observable<T[]>;
export interface BufferWhenSignature<T> {
    (closingSelector: () => Observable<any>): Observable<T[]>;
}
}
declare module 'rxjs-es/operator/bufferWhen' {
export * from '~rxjs-es/operator/bufferWhen';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/bufferWhen.d.ts
declare module '~rxjs-es/add/operator/bufferWhen' {
import { BufferWhenSignature } from '~rxjs-es/operator/bufferWhen';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        bufferWhen: BufferWhenSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/cache.d.ts
declare module '~rxjs-es/operator/cache' {
import { Observable } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
/**
 * @param bufferSize
 * @param windowTime
 * @param scheduler
 * @return {Observable<any>}
 * @method cache
 * @owner Observable
 */
export function cache<T>(bufferSize?: number, windowTime?: number, scheduler?: Scheduler): Observable<T>;
export interface CacheSignature<T> {
    (bufferSize?: number, windowTime?: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module 'rxjs-es/operator/cache' {
export * from '~rxjs-es/operator/cache';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/cache.d.ts
declare module '~rxjs-es/add/operator/cache' {
import { CacheSignature } from '~rxjs-es/operator/cache';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        cache: CacheSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/catch.d.ts
declare module '~rxjs-es/operator/catch' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} an observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @owner Observable
 */
export function _catch<T, R>(selector: (err: any, caught: Observable<T>) => ObservableInput<R>): Observable<R>;
export interface CatchSignature<T> {
    <R>(selector: (err: any, caught: Observable<T>) => ObservableInput<R>): Observable<R>;
}
}
declare module 'rxjs-es/operator/catch' {
export * from '~rxjs-es/operator/catch';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/catch.d.ts
declare module '~rxjs-es/add/operator/catch' {
import { CatchSignature } from '~rxjs-es/operator/catch';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        catch: CatchSignature<T>;
        _catch: CatchSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/combineAll.d.ts
declare module '~rxjs-es/operator/combineAll' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Converts a higher-order Observable into a first-order Observable by waiting
 * for the outer Observable to complete, then applying {@link combineLatest}.
 *
 * <span class="informal">Flattens an Observable-of-Observables by applying
 * {@link combineLatest} when the Observable-of-Observables completes.</span>
 *
 * <img src="./img/combineAll.png" width="100%">
 *
 * Takes an Observable of Observables, and collects all Observables from it.
 * Once the outer Observable completes, it subscribes to all collected
 * Observables and combines their values using the {@link combineLatest}
 * strategy, such that:
 * - Every time an inner Observable emits, the output Observable emits.
 * - When the returned observable emits, it emits all of the latest values by:
 *   - If a `project` function is provided, it is called with each recent value
 *     from each inner Observable in whatever order they arrived, and the result
 *     of the `project` function is what is emitted by the output Observable.
 *   - If there is no `project` function, an array of all of the most recent
 *     values is emitted by the output Observable.
 *
 * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev =>
 *   Rx.Observable.interval(Math.random()*2000).take(3)
 * ).take(2);
 * var result = higherOrder.combineAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 * @see {@link mergeAll}
 *
 * @param {function} [project] An optional function to map the most recent
 * values from each inner Observable into a new result. Takes each of the most
 * recent values from each collected inner Observable as arguments, in order.
 * @return {Observable} An Observable of projected results or arrays of recent
 * values.
 * @method combineAll
 * @owner Observable
 */
export function combineAll<R>(project?: (...values: Array<any>) => R): Observable<R>;
export interface CombineAllSignature<T> {
    <R>(project?: (...values: Array<T>) => R): Observable<R>;
}
}
declare module 'rxjs-es/operator/combineAll' {
export * from '~rxjs-es/operator/combineAll';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/combineAll.d.ts
declare module '~rxjs-es/add/operator/combineAll' {
import { CombineAllSignature } from '~rxjs-es/operator/combineAll';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        combineAll: CombineAllSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/combineLatest.d.ts
declare module '~rxjs-es/operator/combineLatest' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
import { OuterSubscriber } from '~rxjs-es/OuterSubscriber';
import { InnerSubscriber } from '~rxjs-es/InnerSubscriber';
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
export function combineLatest<T, R>(...observables: Array<ObservableInput<any> | Array<ObservableInput<any>> | ((...values: Array<any>) => R)>): Observable<R>;
export interface CombineLatestSignature<T> {
    <R>(project: (v1: T) => R): Observable<R>;
    <T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;
    <T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
    <T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
    <T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
    <T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
    <T2>(v2: ObservableInput<T2>): Observable<[T, T2]>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
    <R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;
    <R>(array: ObservableInput<T>[]): Observable<Array<T>>;
    <TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): Observable<R>;
}
export class CombineLatestOperator<T, R> implements Operator<T, R> {
    private project;
    constructor(project?: (...values: Array<any>) => R);
    call(subscriber: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {
    private project;
    private active;
    private values;
    private observables;
    private toRespond;
    constructor(destination: Subscriber<R>, project?: (...values: Array<any>) => R);
    protected _next(observable: any): void;
    protected _complete(): void;
    notifyComplete(unused: Subscriber<R>): void;
    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
    private _tryProject(values);
}
}
declare module 'rxjs-es/operator/combineLatest' {
export * from '~rxjs-es/operator/combineLatest';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/combineLatest.d.ts
declare module '~rxjs-es/add/operator/combineLatest' {
import { CombineLatestSignature } from '~rxjs-es/operator/combineLatest';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        combineLatest: CombineLatestSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/concat.d.ts
declare module '~rxjs-es/operator/concat' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {Observable} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
export function concat<T, R>(...observables: Array<ObservableInput<any> | Scheduler>): Observable<R>;
export interface ConcatSignature<T> {
    (scheduler?: Scheduler): Observable<T>;
    <T2>(v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<T | T2>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<T | T2 | T3>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
    (...observables: Array<ObservableInput<T> | Scheduler>): Observable<T>;
    <R>(...observables: Array<ObservableInput<any> | Scheduler>): Observable<R>;
}
export function concatStatic<T>(v1: ObservableInput<T>, scheduler?: Scheduler): Observable<T>;
export function concatStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<T | T2>;
export function concatStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<T | T2 | T3>;
export function concatStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
export function concatStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
export function concatStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
export function concatStatic<T>(...observables: (ObservableInput<T> | Scheduler)[]): Observable<T>;
export function concatStatic<T, R>(...observables: (ObservableInput<any> | Scheduler)[]): Observable<R>;
}
declare module 'rxjs-es/operator/concat' {
export * from '~rxjs-es/operator/concat';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/concat.d.ts
declare module '~rxjs-es/add/operator/concat' {
import { ConcatSignature } from '~rxjs-es/operator/concat';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        concat: ConcatSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/concatAll.d.ts
declare module '~rxjs-es/operator/concatAll' {
import { Subscribable } from '~rxjs-es/Observable';
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
export function concatAll<T>(): T;
export interface ConcatAllSignature<T> {
    (): T;
    <R>(): Subscribable<R>;
}
}
declare module 'rxjs-es/operator/concatAll' {
export * from '~rxjs-es/operator/concatAll';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/concatAll.d.ts
declare module '~rxjs-es/add/operator/concatAll' {
import { ConcatAllSignature } from '~rxjs-es/operator/concatAll';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        concatAll: ConcatAllSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/concatMap.d.ts
declare module '~rxjs-es/operator/concatMap' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} an observable of values merged from the projected
 * Observables as they were subscribed to, one at a time. Optionally, these
 * values may have been projected from a passed `projectResult` argument.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
export function concatMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): any;
export interface ConcatMapSignature<T> {
    <R>(project: (value: T, index: number) => ObservableInput<R>): Observable<R>;
    <I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
}
}
declare module 'rxjs-es/operator/concatMap' {
export * from '~rxjs-es/operator/concatMap';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/concatMap.d.ts
declare module '~rxjs-es/add/operator/concatMap' {
import { ConcatMapSignature } from '~rxjs-es/operator/concatMap';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        concatMap: ConcatMapSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/concatMapTo.d.ts
declare module '~rxjs-es/operator/concatMapTo' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in a serialized fashion on the output Observable.
 *
 * <span class="informal">It's like {@link concatMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/concatMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. Each new `innerObservable`
 * instance emitted on the output Observable is concatenated with the previous
 * `innerObservable` instance.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
 * set to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link mergeMapTo}
 * @see {@link switchMapTo}
 *
 * @param {Observable} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */
export function concatMapTo<T, I, R>(innerObservable: Observable<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
export interface ConcatMapToSignature<T> {
    <R>(observable: ObservableInput<R>): Observable<R>;
    <I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
}
}
declare module 'rxjs-es/operator/concatMapTo' {
export * from '~rxjs-es/operator/concatMapTo';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/concatMapTo.d.ts
declare module '~rxjs-es/add/operator/concatMapTo' {
import { ConcatMapToSignature } from '~rxjs-es/operator/concatMapTo';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        concatMapTo: ConcatMapToSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/count.d.ts
declare module '~rxjs-es/operator/count' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Counts the number of emissions on the source and emits that number when the
 * source completes.
 *
 * <span class="informal">Tells how many values were emitted, when the source
 * completes.</span>
 *
 * <img src="./img/count.png" width="100%">
 *
 * `count` transforms an Observable that emits values into an Observable that
 * emits a single value that represents the number of values emitted by the
 * source Observable. If the source Observable terminates with an error, `count`
 * will pass this error notification along without emitting an value first. If
 * the source Observable does not terminate at all, `count` will neither emit
 * a value nor terminate. This operator takes an optional `predicate` function
 * as argument, in which case the output emission will represent the number of
 * source values that matched `true` with the `predicate`.
 *
 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var secondsBeforeClick = seconds.takeUntil(clicks);
 * var result = secondsBeforeClick.count();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
 * var numbers = Rx.Observable.range(1, 7);
 * var result = numbers.count(i => i % 2 === 1);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link max}
 * @see {@link min}
 * @see {@link reduce}
 *
 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
 * boolean function to select what values are to be counted. It is provided with
 * arguments of:
 * - `value`: the value from the source Observable.
 * - `index`: the (zero-based) "index" of the value from the source Observable.
 * - `source`: the source Observable instance itself.
 * @return {Observable} An Observable of one number that represents the count as
 * described above.
 * @method count
 * @owner Observable
 */
export function count<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<number>;
export interface CountSignature<T> {
    (predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<number>;
}
}
declare module 'rxjs-es/operator/count' {
export * from '~rxjs-es/operator/count';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/count.d.ts
declare module '~rxjs-es/add/operator/count' {
import { CountSignature } from '~rxjs-es/operator/count';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        count: CountSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/dematerialize.d.ts
declare module '~rxjs-es/operator/dematerialize' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Converts an Observable of {@link Notification} objects into the emissions
 * that they represent.
 *
 * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
 * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
 *
 * <img src="./img/dematerialize.png" width="100%">
 *
 * `dematerialize` is assumed to operate an Observable that only emits
 * {@link Notification} objects as `next` emissions, and does not emit any
 * `error`. Such Observable is the output of a `materialize` operation. Those
 * notifications are then unwrapped using the metadata they contain, and emitted
 * as `next`, `error`, and `complete` on the output Observable.
 *
 * Use this operator in conjunction with {@link materialize}.
 *
 * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
 * var notifA = new Rx.Notification('N', 'A');
 * var notifB = new Rx.Notification('N', 'B');
 * var notifE = new Rx.Notification('E', void 0,
 *   new TypeError('x.toUpperCase is not a function')
 * );
 * var materialized = Rx.Observable.of(notifA, notifB, notifE);
 * var upperCase = materialized.dematerialize();
 * upperCase.subscribe(x => console.log(x), e => console.error(e));
 *
 * @see {@link Notification}
 * @see {@link materialize}
 *
 * @return {Observable} An Observable that emits items and notifications
 * embedded in Notification objects emitted by the source Observable.
 * @method dematerialize
 * @owner Observable
 */
export function dematerialize<T>(): Observable<any>;
export interface DematerializeSignature<T> {
    <R>(): Observable<R>;
}
}
declare module 'rxjs-es/operator/dematerialize' {
export * from '~rxjs-es/operator/dematerialize';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/dematerialize.d.ts
declare module '~rxjs-es/add/operator/dematerialize' {
import { DematerializeSignature } from '~rxjs-es/operator/dematerialize';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        dematerialize: DematerializeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/debounce.d.ts
declare module '~rxjs-es/operator/debounce' {
import { Observable, SubscribableOrPromise } from '~rxjs-es/Observable';
/**
 * Emits a value from the source Observable only after a particular time span
 * determined by another Observable has passed without another source emission.
 *
 * <span class="informal">It's like {@link debounceTime}, but the time span of
 * emission silence is determined by a second Observable.</span>
 *
 * <img src="./img/debounce.png" width="100%">
 *
 * `debounce` delays values emitted by the source Observable, but drops previous
 * pending delayed emissions if a new value arrives on the source Observable.
 * This operator keeps track of the most recent value from the source
 * Observable, and spawns a duration Observable by calling the
 * `durationSelector` function. The value is emitted only when the duration
 * Observable emits a value or completes, and if no other value was emitted on
 * the source Observable since the duration Observable was spawned. If a new
 * value appears before the duration Observable emits, the previous value will
 * be dropped and will not be emitted on the output Observable.
 *
 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
 * delay-like operator since output emissions do not necessarily occur at the
 * same time as they did on the source Observable.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 * @see {@link throttle}
 *
 * @param {function(value: T): Observable|Promise} durationSelector A function
 * that receives a value from the source Observable, for computing the timeout
 * duration for each source value, returned as an Observable or a Promise.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified duration Observable returned by
 * `durationSelector`, and may drop some values if they occur too frequently.
 * @method debounce
 * @owner Observable
 */
export function debounce<T>(durationSelector: (value: T) => SubscribableOrPromise<number>): Observable<T>;
export interface DebounceSignature<T> {
    (durationSelector: (value: T) => SubscribableOrPromise<number>): Observable<T>;
}
}
declare module 'rxjs-es/operator/debounce' {
export * from '~rxjs-es/operator/debounce';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/debounce.d.ts
declare module '~rxjs-es/add/operator/debounce' {
import { DebounceSignature } from '~rxjs-es/operator/debounce';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        debounce: DebounceSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/debounceTime.d.ts
declare module '~rxjs-es/operator/debounceTime' {
import { Observable } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link Scheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
export function debounceTime<T>(dueTime: number, scheduler?: Scheduler): Observable<T>;
export interface DebounceTimeSignature<T> {
    (dueTime: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module 'rxjs-es/operator/debounceTime' {
export * from '~rxjs-es/operator/debounceTime';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/debounceTime.d.ts
declare module '~rxjs-es/add/operator/debounceTime' {
import { DebounceTimeSignature } from '~rxjs-es/operator/debounceTime';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        debounceTime: DebounceTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/defaultIfEmpty.d.ts
declare module '~rxjs-es/operator/defaultIfEmpty' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits a given value if the source Observable completes without emitting any
 * `next` value, otherwise mirrors the source Observable.
 *
 * <span class="informal">If the source Observable turns out to be empty, then
 * this operator will emit a default value.</span>
 *
 * <img src="./img/defaultIfEmpty.png" width="100%">
 *
 * `defaultIfEmpty` emits the values emitted by the source Observable or a
 * specified default value if the source Observable is empty (completes without
 * having emitted any `next` value).
 *
 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link empty}
 * @see {@link last}
 *
 * @param {any} [defaultValue=null] The default value used if the source
 * Observable is empty.
 * @return {Observable} An Observable that emits either the specified
 * `defaultValue` if the source Observable emits no items, or the values emitted
 * by the source Observable.
 * @method defaultIfEmpty
 * @owner Observable
 */
export function defaultIfEmpty<T, R>(defaultValue?: R): Observable<T | R>;
export interface DefaultIfEmptySignature<T> {
    (defaultValue?: T): Observable<T>;
    <R>(defaultValue?: R): Observable<T | R>;
}
}
declare module 'rxjs-es/operator/defaultIfEmpty' {
export * from '~rxjs-es/operator/defaultIfEmpty';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/defaultIfEmpty.d.ts
declare module '~rxjs-es/add/operator/defaultIfEmpty' {
import { DefaultIfEmptySignature } from '~rxjs-es/operator/defaultIfEmpty';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        defaultIfEmpty: DefaultIfEmptySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/delay.d.ts
declare module '~rxjs-es/operator/delay' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The Scheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
export function delay<T>(delay: number | Date, scheduler?: Scheduler): Observable<T>;
export interface DelaySignature<T> {
    (delay: number | Date, scheduler?: Scheduler): Observable<T>;
}
}
declare module 'rxjs-es/operator/delay' {
export * from '~rxjs-es/operator/delay';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/delay.d.ts
declare module '~rxjs-es/add/operator/delay' {
import { DelaySignature } from '~rxjs-es/operator/delay';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        delay: DelaySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/delayWhen.d.ts
declare module '~rxjs-es/operator/delayWhen' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Delays the emission of items from the source Observable by a given time span
 * determined by the emissions of another Observable.
 *
 * <span class="informal">It's like {@link delay}, but the time span of the
 * delay duration is determined by a second Observable.</span>
 *
 * <img src="./img/delayWhen.png" width="100%">
 *
 * `delayWhen` time shifts each emitted value from the source Observable by a
 * time span determined by another Observable. When the source emits a value,
 * the `delayDurationSelector` function is called with the source value as
 * argument, and should return an Observable, called the "duration" Observable.
 * The source value is emitted on the output Observable only when the duration
 * Observable emits a value or completes.
 *
 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
 * is an Observable. When `subscriptionDelay` emits its first value or
 * completes, the source Observable is subscribed to and starts behaving like
 * described in the previous paragraph. If `subscriptionDelay` is not provided,
 * `delayWhen` will subscribe to the source Observable as soon as the output
 * Observable is subscribed.
 *
 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delayWhen(event =>
 *   Rx.Observable.interval(Math.random() * 5000)
 * );
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounce}
 * @see {@link delay}
 *
 * @param {function(value: T): Observable} delayDurationSelector A function that
 * returns an Observable for each value emitted by the source Observable, which
 * is then used to delay the emission of that item on the output Observable
 * until the Observable returned from this function emits a value.
 * @param {Observable} subscriptionDelay An Observable that triggers the
 * subscription to the source Observable once it emits any value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by an amount of time specified by the Observable returned by
 * `delayDurationSelector`.
 * @method delayWhen
 * @owner Observable
 */
export function delayWhen<T>(delayDurationSelector: (value: T) => Observable<any>, subscriptionDelay?: Observable<any>): Observable<T>;
export interface DelayWhenSignature<T> {
    (delayDurationSelector: (value: T) => Observable<any>, subscriptionDelay?: Observable<any>): Observable<T>;
}
}
declare module 'rxjs-es/operator/delayWhen' {
export * from '~rxjs-es/operator/delayWhen';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/delayWhen.d.ts
declare module '~rxjs-es/add/operator/delayWhen' {
import { DelayWhenSignature } from '~rxjs-es/operator/delayWhen';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        delayWhen: DelayWhenSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/distinct.d.ts
declare module '~rxjs-es/operator/distinct' {
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { OuterSubscriber } from '~rxjs-es/OuterSubscriber';
import { InnerSubscriber } from '~rxjs-es/InnerSubscriber';
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 * If a comparator function is not provided, an equality check is used by default.
 * As the internal HashSet of this operator grows larger and larger, care should be taken in the domain of inputs this operator may see.
 * An optional parameter is also provided such that an Observable can be provided to queue the internal HashSet to flush the values it holds.
 * @param {function} [compare] optional comparison function called to test if an item is distinct from previous items in the source.
 * @param {Observable} [flushes] optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */
export function distinct<T>(compare?: (x: T, y: T) => boolean, flushes?: Observable<any>): Observable<T>;
export interface DistinctSignature<T> {
    (compare?: (x: T, y: T) => boolean, flushes?: Observable<any>): Observable<T>;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class DistinctSubscriber<T> extends OuterSubscriber<T, T> {
    private values;
    constructor(destination: Subscriber<T>, compare: (x: T, y: T) => boolean, flushes: Observable<any>);
    notifyNext(outerValue: T, innerValue: T, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, T>): void;
    notifyError(error: any, innerSub: InnerSubscriber<T, T>): void;
    protected _next(value: T): void;
    private compare(x, y);
}
}
declare module 'rxjs-es/operator/distinct' {
export * from '~rxjs-es/operator/distinct';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/distinct.d.ts
declare module '~rxjs-es/add/operator/distinct' {
import { DistinctSignature } from '~rxjs-es/operator/distinct';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        distinct: DistinctSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/distinctKey.d.ts
declare module '~rxjs-es/operator/distinctKey' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items,
 * using a property accessed by using the key provided to check if the two items are distinct.
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 * If a comparator function is not provided, an equality check is used by default.
 * As the internal HashSet of this operator grows larger and larger, care should be taken in the domain of inputs this operator may see.
 * An optional parameter is also provided such that an Observable can be provided to queue the internal HashSet to flush the values it holds.
 * @param {string} key string key for object property lookup on each item.
 * @param {function} [compare] optional comparison function called to test if an item is distinct from previous items in the source.
 * @param {Observable} [flushes] optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
 * @method distinctKey
 * @owner Observable
 */
export function distinctKey<T>(key: string, compare?: (x: T, y: T) => boolean, flushes?: Observable<any>): Observable<T>;
export interface DistinctKeySignature<T> {
    (key: string): Observable<T>;
    <K>(key: string, compare: (x: K, y: K) => boolean, flushes?: Observable<any>): Observable<T>;
}
}
declare module 'rxjs-es/operator/distinctKey' {
export * from '~rxjs-es/operator/distinctKey';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/distinctKey.d.ts
declare module '~rxjs-es/add/operator/distinctKey' {
import { DistinctKeySignature } from '~rxjs-es/operator/distinctKey';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        distinctKey: DistinctKeySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/distinctUntilChanged.d.ts
declare module '~rxjs-es/operator/distinctUntilChanged' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 * If a comparator function is not provided, an equality check is used by default.
 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
export function distinctUntilChanged<T, K>(compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): Observable<T>;
export interface DistinctUntilChangedSignature<T> {
    (compare?: (x: T, y: T) => boolean): Observable<T>;
    <K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): Observable<T>;
}
}
declare module 'rxjs-es/operator/distinctUntilChanged' {
export * from '~rxjs-es/operator/distinctUntilChanged';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/distinctUntilChanged.d.ts
declare module '~rxjs-es/add/operator/distinctUntilChanged' {
import { DistinctUntilChangedSignature } from '~rxjs-es/operator/distinctUntilChanged';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        distinctUntilChanged: DistinctUntilChangedSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/distinctUntilKeyChanged.d.ts
declare module '~rxjs-es/operator/distinctUntilKeyChanged' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 * If a comparator function is not provided, an equality check is used by default.
 * @param {string} key string key for object property lookup on each item.
 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} an Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */
export function distinctUntilKeyChanged<T>(key: string, compare?: (x: T, y: T) => boolean): Observable<T>;
export interface DistinctUntilKeyChangedSignature<T> {
    (key: string): Observable<T>;
    <K>(key: string, compare: (x: K, y: K) => boolean): Observable<T>;
}
}
declare module 'rxjs-es/operator/distinctUntilKeyChanged' {
export * from '~rxjs-es/operator/distinctUntilKeyChanged';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/distinctUntilKeyChanged.d.ts
declare module '~rxjs-es/add/operator/distinctUntilKeyChanged' {
import { DistinctUntilKeyChangedSignature } from '~rxjs-es/operator/distinctUntilKeyChanged';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        distinctUntilKeyChanged: DistinctUntilKeyChangedSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/do.d.ts
declare module '~rxjs-es/operator/do' {
import { Observable } from '~rxjs-es/Observable';
import { PartialObserver } from '~rxjs-es/Observer';
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
export function _do<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void), error?: (e: any) => void, complete?: () => void): Observable<T>;
export interface DoSignature<T> {
    (next: (x: T) => void, error?: (e: any) => void, complete?: () => void): Observable<T>;
    (observer: PartialObserver<T>): Observable<T>;
}
}
declare module 'rxjs-es/operator/do' {
export * from '~rxjs-es/operator/do';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/do.d.ts
declare module '~rxjs-es/add/operator/do' {
import { DoSignature } from '~rxjs-es/operator/do';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        do: DoSignature<T>;
        _do: DoSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/exhaust.d.ts
declare module '~rxjs-es/operator/exhaust' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Converts a higher-order Observable into a first-order Observable by dropping
 * inner Observables while the previous inner Observable has not yet completed.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * next inner Observables while the current inner is still executing.</span>
 *
 * <img src="./img/exhaust.png" width="100%">
 *
 * `exhaust` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable begins emitting the items emitted by that
 * inner Observable. So far, it behaves like {@link mergeAll}. However,
 * `exhaust` ignores every new inner Observable if the previous Observable has
 * not yet completed. Once that one completes, it will accept and flatten the
 * next inner Observable and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var result = higherOrder.exhaust();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link switch}
 * @see {@link mergeAll}
 * @see {@link exhaustMap}
 * @see {@link zipAll}
 *
 * @return {Observable} Returns an Observable that takes a source of Observables
 * and propagates the first observable exclusively until it completes before
 * subscribing to the next.
 * @method exhaust
 * @owner Observable
 */
export function exhaust<T>(): Observable<T>;
export interface SwitchFirstSignature<T> {
    (): T;
}
}
declare module 'rxjs-es/operator/exhaust' {
export * from '~rxjs-es/operator/exhaust';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/exhaust.d.ts
declare module '~rxjs-es/add/operator/exhaust' {
import { SwitchFirstSignature } from '~rxjs-es/operator/exhaust';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        exhaust: SwitchFirstSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/exhaustMap.d.ts
declare module '~rxjs-es/operator/exhaustMap' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
export function exhaustMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
export interface SwitchFirstMapSignature<T> {
    <R>(project: (value: T, index: number) => ObservableInput<R>): Observable<R>;
    <I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
}
}
declare module 'rxjs-es/operator/exhaustMap' {
export * from '~rxjs-es/operator/exhaustMap';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/exhaustMap.d.ts
declare module '~rxjs-es/add/operator/exhaustMap' {
import { SwitchFirstMapSignature } from '~rxjs-es/operator/exhaustMap';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        exhaustMap: SwitchFirstMapSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/expand.d.ts
declare module '~rxjs-es/operator/expand' {
import { Observable } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
import { OuterSubscriber } from '~rxjs-es/OuterSubscriber';
import { InnerSubscriber } from '~rxjs-es/InnerSubscriber';
/**
 * Recursively projects each source value to an Observable which is merged in
 * the output Observable.
 *
 * <span class="informal">It's similar to {@link mergeMap}, but applies the
 * projection function to every source value as well as every output value.
 * It's recursive.</span>
 *
 * <img src="./img/expand.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger. *Expand* will re-emit on the output
 * Observable every source value. Then, each output value is given to the
 * `project` function which returns an inner Observable to be merged on the
 * output Observable. Those output values resulting from the projection are also
 * given to the `project` function to produce new output values. This is how
 * *expand* behaves recursively.
 *
 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var powersOfTwo = clicks
 *   .mapTo(1)
 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
 *   .take(10);
 * powersOfTwo.subscribe(x => console.log(x));
 *
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 *
 * @param {function(value: T, index: number) => Observable} project A function
 * that, when applied to an item emitted by the source or the output Observable,
 * returns an Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The Scheduler to use for subscribing to
 * each projected inner Observable.
 * @return {Observable} An Observable that emits the source values and also
 * result of applying the projection function to each value emitted on the
 * output Observable and and merging the results of the Observables obtained
 * from this transformation.
 * @method expand
 * @owner Observable
 */
export function expand<T, R>(project: (value: T, index: number) => Observable<R>, concurrent?: number, scheduler?: Scheduler): Observable<R>;
export interface ExpandSignature<T> {
    (project: (value: T, index: number) => Observable<T>, concurrent?: number, scheduler?: Scheduler): Observable<T>;
    <R>(project: (value: T, index: number) => Observable<R>, concurrent?: number, scheduler?: Scheduler): Observable<R>;
}
export class ExpandOperator<T, R> implements Operator<T, R> {
    private project;
    private concurrent;
    private scheduler;
    constructor(project: (value: T, index: number) => Observable<R>, concurrent: number, scheduler: Scheduler);
    call(subscriber: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class ExpandSubscriber<T, R> extends OuterSubscriber<T, R> {
    private project;
    private concurrent;
    private scheduler;
    private index;
    private active;
    private hasCompleted;
    private buffer;
    constructor(destination: Subscriber<R>, project: (value: T, index: number) => Observable<R>, concurrent: number, scheduler: Scheduler);
    private static dispatch<T, R>(arg);
    protected _next(value: any): void;
    private subscribeToProjection(result, value, index);
    protected _complete(): void;
    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
    notifyComplete(innerSub: Subscription): void;
}
}
declare module 'rxjs-es/operator/expand' {
export * from '~rxjs-es/operator/expand';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/expand.d.ts
declare module '~rxjs-es/add/operator/expand' {
import { ExpandSignature } from '~rxjs-es/operator/expand';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        expand: ExpandSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/elementAt.d.ts
declare module '~rxjs-es/operator/elementAt' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits the single value at the specified `index` in a sequence of emissions
 * from the source Observable.
 *
 * <span class="informal">Emits only the i-th value, then completes.</span>
 *
 * <img src="./img/elementAt.png" width="100%">
 *
 * `elementAt` returns an Observable that emits the item at the specified
 * `index` in the source Observable, or a default value if that `index` is out
 * of range and the `default` argument is provided. If the `default` argument is
 * not given and the `index` is out of range, the output Observable will emit an
 * `ArgumentOutOfRangeError` error.
 *
 * @example <caption>Emit only the third click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.elementAt(2);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link skip}
 * @see {@link single}
 * @see {@link take}
 *
 * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
 * Observable has completed before emitting the i-th `next` notification.
 *
 * @param {number} index Is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {T} [defaultValue] The default value returned for missing indices.
 * @return {Observable} An Observable that emits a single item, if it is found.
 * Otherwise, will emit the default value if given. If not, then emits an error.
 * @method elementAt
 * @owner Observable
 */
export function elementAt<T>(index: number, defaultValue?: T): Observable<T>;
export interface ElementAtSignature<T> {
    (index: number, defaultValue?: T): Observable<T>;
}
}
declare module 'rxjs-es/operator/elementAt' {
export * from '~rxjs-es/operator/elementAt';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/elementAt.d.ts
declare module '~rxjs-es/add/operator/elementAt' {
import { ElementAtSignature } from '~rxjs-es/operator/elementAt';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        elementAt: ElementAtSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/filter.d.ts
declare module '~rxjs-es/operator/filter' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctKey}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
export function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): Observable<T>;
export interface FilterSignature<T> {
    (predicate: (value: T, index: number) => boolean, thisArg?: any): Observable<T>;
}
}
declare module 'rxjs-es/operator/filter' {
export * from '~rxjs-es/operator/filter';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/filter.d.ts
declare module '~rxjs-es/add/operator/filter' {
import { FilterSignature } from '~rxjs-es/operator/filter';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        filter: FilterSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/finally.d.ts
declare module '~rxjs-es/operator/finally' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback function to be called when source terminates.
 * @return {Observable} an Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
export function _finally<T>(callback: () => void): Observable<T>;
export interface FinallySignature<T> {
    (callback: () => void): Observable<T>;
}
}
declare module 'rxjs-es/operator/finally' {
export * from '~rxjs-es/operator/finally';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/finally.d.ts
declare module '~rxjs-es/add/operator/finally' {
import { FinallySignature } from '~rxjs-es/operator/finally';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        finally: FinallySignature<T>;
        _finally: FinallySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/find.d.ts
declare module '~rxjs-es/operator/find' {
import { Observable } from '~rxjs-es/Observable';
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
/**
 * Emits only the first value emitted by the source Observable that meets some
 * condition.
 *
 * <span class="informal">Finds the first value that passes some test and emits
 * that.</span>
 *
 * <img src="./img/find.png" width="100%">
 *
 * `find` searches for the first item in the source Observable that matches the
 * specified condition embodied by the `predicate`, and returns the first
 * occurrence in the source. Unlike {@link first}, the `predicate` is required
 * in `find`, and does not emit an error if a valid value is not found.
 *
 * @example <caption>Find and emit the first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.find(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link first}
 * @see {@link findIndex}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable<T>} An Observable of the first item that matches the
 * condition.
 * @method find
 * @owner Observable
 */
export function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>;
export interface FindSignature<T> {
    (predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>;
}
export class FindValueOperator<T> implements Operator<T, T> {
    private predicate;
    private source;
    private yieldIndex;
    private thisArg;
    constructor(predicate: (value: T, index: number, source: Observable<T>) => boolean, source: Observable<T>, yieldIndex: boolean, thisArg?: any);
    call(observer: Subscriber<T>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class FindValueSubscriber<T> extends Subscriber<T> {
    private predicate;
    private source;
    private yieldIndex;
    private thisArg;
    private index;
    constructor(destination: Subscriber<T>, predicate: (value: T, index: number, source: Observable<T>) => boolean, source: Observable<T>, yieldIndex: boolean, thisArg?: any);
    private notifyComplete(value);
    protected _next(value: T): void;
    protected _complete(): void;
}
}
declare module 'rxjs-es/operator/find' {
export * from '~rxjs-es/operator/find';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/find.d.ts
declare module '~rxjs-es/add/operator/find' {
import { FindSignature } from '~rxjs-es/operator/find';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        find: FindSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/findIndex.d.ts
declare module '~rxjs-es/operator/findIndex' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits only the index of the first value emitted by the source Observable that
 * meets some condition.
 *
 * <span class="informal">It's like {@link find}, but emits the index of the
 * found value, not the value itself.</span>
 *
 * <img src="./img/findIndex.png" width="100%">
 *
 * `findIndex` searches for the first item in the source Observable that matches
 * the specified condition embodied by the `predicate`, and returns the
 * (zero-based) index of the first occurrence in the source. Unlike
 * {@link first}, the `predicate` is required in `findIndex`, and does not emit
 * an error if a valid value is not found.
 *
 * @example <caption>Emit the index of first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link first}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of the index of the first item that
 * matches the condition.
 * @method find
 * @owner Observable
 */
export function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<number>;
export interface FindIndexSignature<T> {
    (predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<number>;
}
}
declare module 'rxjs-es/operator/findIndex' {
export * from '~rxjs-es/operator/findIndex';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/findIndex.d.ts
declare module '~rxjs-es/add/operator/findIndex' {
import { FindIndexSignature } from '~rxjs-es/operator/findIndex';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        findIndex: FindIndexSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/first.d.ts
declare module '~rxjs-es/operator/first' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits only the first value (or the first value that meets some condition)
 * emitted by the source Observable.
 *
 * <span class="informal">Emits only the first value. Or emits only the first
 * value that passes some test.</span>
 *
 * <img src="./img/first.png" width="100%">
 *
 * If called with no arguments, `first` emits the first value of the source
 * Observable, then completes. If called with a `predicate` function, `first`
 * emits the first value of the source that matches the specified condition. It
 * may also take a `resultSelector` function to produce the output value from
 * the input value, and a `defaultValue` to emit in case the source completes
 * before it is able to emit a valid value. Throws an error if `defaultValue`
 * was not provided and a matching element is not found.
 *
 * @example <caption>Emit only the first click that happens on the DOM</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Emits the first click that happens on a DIV</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link take}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
 * An optional function called with each item to test for condition matching.
 * @param {function(value: T, index: number): R} [resultSelector] A function to
 * produce the value on the output Observable based on the values
 * and the indices of the source Observable. The arguments passed to this
 * function are:
 * - `value`: the value that was emitted on the source.
 * - `index`: the "index" of the value from the source.
 * @param {R} [defaultValue] The default value emitted in case no valid value
 * was found on the source.
 * @return {Observable<T|R>} an Observable of the first item that matches the
 * condition.
 * @method first
 * @owner Observable
 */
export function first<T, R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, resultSelector?: (value: T, index: number) => R, defaultValue?: R): Observable<T | R>;
export interface FirstSignature<T> {
    (predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<T>;
    (predicate: (value: T, index: number, source: Observable<T>) => boolean, resultSelector: void, defaultValue?: T): Observable<T>;
    <R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, resultSelector?: (value: T, index: number) => R, defaultValue?: R): Observable<R>;
}
}
declare module 'rxjs-es/operator/first' {
export * from '~rxjs-es/operator/first';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/first.d.ts
declare module '~rxjs-es/add/operator/first' {
import { FirstSignature } from '~rxjs-es/operator/first';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        first: FirstSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/groupBy.d.ts
declare module '~rxjs-es/operator/groupBy' {
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
import { Observable } from '~rxjs-es/Observable';
import { Subject } from '~rxjs-es/Subject';
/**
 * Groups the items emitted by an Observable according to a specified criterion,
 * and emits these grouped items as `GroupedObservables`, one
 * {@link GroupedObservable} per group.
 *
 * <img src="./img/groupBy.png" width="100%">
 *
 * @param {function(value: T): K} keySelector a function that extracts the key
 * for each item.
 * @param {function(value: T): R} [elementSelector] a function that extracts the
 * return element for each item.
 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
 * a function that returns an Observable to determine how long each group should
 * exist.
 * @return {Observable<GroupedObservable<K,R>>} an Observable that emits
 * GroupedObservables, each of which corresponds to a unique key value and each
 * of which emits those items from the source Observable that share that key
 * value.
 * @method groupBy
 * @owner Observable
 */
export function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): Observable<GroupedObservable<K, R>>;
export interface GroupBySignature<T> {
    <K>(keySelector: (value: T) => K): Observable<GroupedObservable<K, T>>;
    <K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): Observable<GroupedObservable<K, T>>;
    <K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): Observable<GroupedObservable<K, R>>;
}
export interface RefCountSubscription {
    count: number;
    unsubscribe: () => void;
    closed: boolean;
    attemptedToUnsubscribe: boolean;
}
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
export class GroupedObservable<K, T> extends Observable<T> {
    key: K;
    private groupSubject;
    private refCountSubscription;
    constructor(key: K, groupSubject: Subject<T>, refCountSubscription?: RefCountSubscription);
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
}
}
declare module 'rxjs-es/operator/groupBy' {
export * from '~rxjs-es/operator/groupBy';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/groupBy.d.ts
declare module '~rxjs-es/add/operator/groupBy' {
import { GroupBySignature } from '~rxjs-es/operator/groupBy';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        groupBy: GroupBySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/ignoreElements.d.ts
declare module '~rxjs-es/operator/ignoreElements' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} an empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
export function ignoreElements<T>(): Observable<T>;
export interface IgnoreElementsSignature<T> {
    (): Observable<T>;
}
}
declare module 'rxjs-es/operator/ignoreElements' {
export * from '~rxjs-es/operator/ignoreElements';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/ignoreElements.d.ts
declare module '~rxjs-es/add/operator/ignoreElements' {
import { IgnoreElementsSignature } from '~rxjs-es/operator/ignoreElements';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        ignoreElements: IgnoreElementsSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/isEmpty.d.ts
declare module '~rxjs-es/operator/isEmpty' {
import { Observable } from '~rxjs-es/Observable';
/**
 * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.
 *
 * <img src="./img/isEmpty.png" width="100%">
 *
 * @return {Observable} an Observable that emits a Boolean.
 * @method isEmpty
 * @owner Observable
 */
export function isEmpty(): Observable<boolean>;
export interface IsEmptySignature<T> {
    (): Observable<boolean>;
}
}
declare module 'rxjs-es/operator/isEmpty' {
export * from '~rxjs-es/operator/isEmpty';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/isEmpty.d.ts
declare module '~rxjs-es/add/operator/isEmpty' {
import { IsEmptySignature } from '~rxjs-es/operator/isEmpty';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        isEmpty: IsEmptySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/audit.d.ts
declare module '~rxjs-es/operator/audit' {
import { Observable, SubscribableOrPromise } from '~rxjs-es/Observable';
/**
 * Ignores source values for a duration determined by another Observable, then
 * emits the most recent value from the source Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link auditTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/audit.png" width="100%">
 *
 * `audit` is similar to `throttle`, but emits the last value from the silenced
 * time window, instead of the first value. `audit` emits the most recent value
 * from the source Observable on the output Observable as soon as its internal
 * timer becomes disabled, and ignores source values while the timer is enabled.
 * Initially, the timer is disabled. As soon as the first source value arrives,
 * the timer is enabled by calling the `durationSelector` function with the
 * source value, which returns the "duration" Observable. When the duration
 * Observable emits a value or completes, the timer is disabled, then the most
 * recent source value is emitted on the output Observable, and this process
 * repeats for the next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttle}
 *
 * @param {function(value: T): Observable|Promise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method audit
 * @owner Observable
 */
export function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): Observable<T>;
export interface AuditSignature<T> {
    (durationSelector: (value: T) => SubscribableOrPromise<any>): Observable<T>;
}
}
declare module 'rxjs-es/operator/audit' {
export * from '~rxjs-es/operator/audit';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/audit.d.ts
declare module '~rxjs-es/add/operator/audit' {
import { AuditSignature } from '~rxjs-es/operator/audit';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        audit: AuditSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/auditTime.d.ts
declare module '~rxjs-es/operator/auditTime' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
/**
 * Ignores source values for `duration` milliseconds, then emits the most recent
 * value from the source Observable, then repeats this process.
 *
 * <span class="informal">When it sees a source values, it ignores that plus
 * the next ones for `duration` milliseconds, and then it emits the most recent
 * value from the source.</span>
 *
 * <img src="./img/auditTime.png" width="100%">
 *
 * `auditTime` is similar to `throttleTime`, but emits the last value from the
 * silenced time window, instead of the first value. `auditTime` emits the most
 * recent value from the source Observable on the output Observable as soon as
 * its internal timer becomes disabled, and ignores source values while the
 * timer is enabled. Initially, the timer is disabled. As soon as the first
 * source value arrives, the timer is enabled. After `duration` milliseconds (or
 * the time unit determined internally by the optional `scheduler`) has passed,
 * the timer is disabled, then the most recent source value is emitted on the
 * output Observable, and this process repeats for the next source value.
 * Optionally takes a {@link Scheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.auditTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} duration Time to wait before emitting the most recent source
 * value, measured in milliseconds or the time unit determined internally
 * by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
 * managing the timers that handle the rate-limiting behavior.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method auditTime
 * @owner Observable
 */
export function auditTime<T>(duration: number, scheduler?: Scheduler): Observable<T>;
export interface AuditTimeSignature<T> {
    (duration: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module 'rxjs-es/operator/auditTime' {
export * from '~rxjs-es/operator/auditTime';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/auditTime.d.ts
declare module '~rxjs-es/add/operator/auditTime' {
import { AuditTimeSignature } from '~rxjs-es/operator/auditTime';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        auditTime: AuditTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/last.d.ts
declare module '~rxjs-es/operator/last' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * <img src="./img/last.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} predicate - the condition any source emitted item has to satisfy.
 * @return {Observable} an Observable that emits only the last item satisfying the given condition
 * from the source, or an NoSuchElementException if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 * @method last
 * @owner Observable
 */
export function last<T, R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, resultSelector?: (value: T, index: number) => R | void, defaultValue?: R): Observable<T | R>;
export interface LastSignature<T> {
    (predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<T>;
    (predicate: (value: T, index: number, source: Observable<T>) => boolean, resultSelector: void, defaultValue?: T): Observable<T>;
    <R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, resultSelector?: (value: T, index: number) => R, defaultValue?: R): Observable<R>;
}
}
declare module 'rxjs-es/operator/last' {
export * from '~rxjs-es/operator/last';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/last.d.ts
declare module '~rxjs-es/add/operator/last' {
import { LastSignature } from '~rxjs-es/operator/last';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        last: LastSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/let.d.ts
declare module '~rxjs-es/operator/let' {
import { Observable } from '~rxjs-es/Observable';
/**
 * @param func
 * @return {Observable<R>}
 * @method let
 * @owner Observable
 */
export function letProto<T, R>(func: (selector: Observable<T>) => Observable<R>): Observable<R>;
export interface LetSignature<T> {
    <R>(func: (selector: Observable<T>) => Observable<R>): Observable<R>;
}
}
declare module 'rxjs-es/operator/let' {
export * from '~rxjs-es/operator/let';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/let.d.ts
declare module '~rxjs-es/add/operator/let' {
import { LetSignature } from '~rxjs-es/operator/let';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        let: LetSignature<T>;
        letBind: LetSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/every.d.ts
declare module '~rxjs-es/operator/every' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
 * @param {function} predicate a function for determining if an item meets a specified condition.
 * @param {any} [thisArg] optional object to use for `this` in the callback
 * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.
 * @method every
 * @owner Observable
 */
export function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<boolean>;
export interface EverySignature<T> {
    (predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<boolean>;
}
}
declare module 'rxjs-es/operator/every' {
export * from '~rxjs-es/operator/every';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/every.d.ts
declare module '~rxjs-es/add/operator/every' {
import { EverySignature } from '~rxjs-es/operator/every';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        every: EverySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/map.d.ts
declare module '~rxjs-es/operator/map' {
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Observable } from '~rxjs-es/Observable';
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
export function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): Observable<R>;
export interface MapSignature<T> {
    <R>(project: (value: T, index: number) => R, thisArg?: any): Observable<R>;
}
export class MapOperator<T, R> implements Operator<T, R> {
    private project;
    private thisArg;
    constructor(project: (value: T, index: number) => R, thisArg: any);
    call(subscriber: Subscriber<R>, source: any): any;
}
}
declare module 'rxjs-es/operator/map' {
export * from '~rxjs-es/operator/map';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/map.d.ts
declare module '~rxjs-es/add/operator/map' {
import { MapSignature } from '~rxjs-es/operator/map';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        map: MapSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/mapTo.d.ts
declare module '~rxjs-es/operator/mapTo' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
export function mapTo<T, R>(value: R): Observable<R>;
export interface MapToSignature<T> {
    <R>(value: R): Observable<R>;
}
}
declare module 'rxjs-es/operator/mapTo' {
export * from '~rxjs-es/operator/mapTo';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/mapTo.d.ts
declare module '~rxjs-es/add/operator/mapTo' {
import { MapToSignature } from '~rxjs-es/operator/mapTo';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        mapTo: MapToSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/materialize.d.ts
declare module '~rxjs-es/operator/materialize' {
import { Observable } from '~rxjs-es/Observable';
import { Notification } from '~rxjs-es/Notification';
/**
 * Represents all of the notifications from the source Observable as `next`
 * emissions marked with their original types within {@link Notification}
 * objects.
 *
 * <span class="informal">Wraps `next`, `error` and `complete` emissions in
 * {@link Notification} objects, emitted as `next` on the output Observable.
 * </span>
 *
 * <img src="./img/materialize.png" width="100%">
 *
 * `materialize` returns an Observable that emits a `next` notification for each
 * `next`, `error`, or `complete` emission of the source Observable. When the
 * source Observable emits `complete`, the output Observable will emit `next` as
 * a Notification of type "complete", and then it will emit `complete` as well.
 * When the source Observable emits `error`, the output will emit `next` as a
 * Notification of type "error", and then `complete`.
 *
 * This operator is useful for producing metadata of the source Observable, to
 * be consumed as `next` emissions. Use it in conjunction with
 * {@link dematerialize}.
 *
 * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
 * var letters = Rx.Observable.of('a', 'b', 13, 'd');
 * var upperCase = letters.map(x => x.toUpperCase());
 * var materialized = upperCase.materialize();
 * materialized.subscribe(x => console.log(x));
 *
 * @see {@link Notification}
 * @see {@link dematerialize}
 *
 * @return {Observable<Notification<T>>} An Observable that emits
 * {@link Notification} objects that wrap the original emissions from the source
 * Observable with metadata.
 * @method materialize
 * @owner Observable
 */
export function materialize<T>(): Observable<Notification<T>>;
export interface MaterializeSignature<T> {
    (): Observable<Notification<T>>;
}
}
declare module 'rxjs-es/operator/materialize' {
export * from '~rxjs-es/operator/materialize';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/materialize.d.ts
declare module '~rxjs-es/add/operator/materialize' {
import { MaterializeSignature } from '~rxjs-es/operator/materialize';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        materialize: MaterializeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/max.d.ts
declare module '~rxjs-es/operator/max' {
import { Observable } from '~rxjs-es/Observable';
/**
 * The Max operator operates on an Observable that emits numbers (or items that can be evaluated as numbers),
 * and when source Observable completes it emits a single item: the item with the largest number.
 *
 * <img src="./img/max.png" width="100%">
 *
 * @param {Function} optional comparer function that it will use instead of its default to compare the value of two
 * items.
 * @return {Observable} an Observable that emits item with the largest number.
 * @method max
 * @owner Observable
 */
export function max<T>(comparer?: (x: T, y: T) => number): Observable<T>;
export interface MaxSignature<T> {
    (comparer?: (x: T, y: T) => number): Observable<T>;
}
}
declare module 'rxjs-es/operator/max' {
export * from '~rxjs-es/operator/max';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/max.d.ts
declare module '~rxjs-es/add/operator/max' {
import { MaxSignature } from '~rxjs-es/operator/max';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        max: MaxSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/merge.d.ts
declare module '~rxjs-es/operator/merge' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {Observable} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
export function merge<T, R>(...observables: Array<ObservableInput<any> | Scheduler | number>): Observable<R>;
export interface MergeSignature<T> {
    (scheduler?: Scheduler): Observable<T>;
    (concurrent?: number, scheduler?: Scheduler): Observable<T>;
    <T2>(v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<T | T2>;
    <T2>(v2: ObservableInput<T2>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<T | T2 | T3>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
    (...observables: Array<ObservableInput<T> | Scheduler | number>): Observable<T>;
    <R>(...observables: Array<ObservableInput<any> | Scheduler | number>): Observable<R>;
}
export function mergeStatic<T>(v1: ObservableInput<T>, scheduler?: Scheduler): Observable<T>;
export function mergeStatic<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: Scheduler): Observable<T>;
export function mergeStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<T | T2>;
export function mergeStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2>;
export function mergeStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<T | T2 | T3>;
export function mergeStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3>;
export function mergeStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
export function mergeStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
export function mergeStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
export function mergeStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
export function mergeStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
export function mergeStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
export function mergeStatic<T>(...observables: (ObservableInput<T> | Scheduler | number)[]): Observable<T>;
export function mergeStatic<T, R>(...observables: (ObservableInput<any> | Scheduler | number)[]): Observable<R>;
}
declare module 'rxjs-es/operator/merge' {
export * from '~rxjs-es/operator/merge';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/merge.d.ts
declare module '~rxjs-es/add/operator/merge' {
import { MergeSignature } from '~rxjs-es/operator/merge';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        merge: MergeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/mergeAll.d.ts
declare module '~rxjs-es/operator/mergeAll' {
import { Observable } from '~rxjs-es/Observable';
import { Operator } from '~rxjs-es/Operator';
import { Observer } from '~rxjs-es/Observer';
import { Subscription } from '~rxjs-es/Subscription';
import { OuterSubscriber } from '~rxjs-es/OuterSubscriber';
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
export function mergeAll<T>(concurrent?: number): T;
export interface MergeAllSignature<T> {
    (concurrent?: number): T;
}
export class MergeAllOperator<T> implements Operator<Observable<T>, T> {
    private concurrent;
    constructor(concurrent: number);
    call(observer: Observer<T>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class MergeAllSubscriber<T> extends OuterSubscriber<Observable<T>, T> {
    private concurrent;
    private hasCompleted;
    private buffer;
    private active;
    constructor(destination: Observer<T>, concurrent: number);
    protected _next(observable: Observable<T>): void;
    protected _complete(): void;
    notifyComplete(innerSub: Subscription): void;
}
}
declare module 'rxjs-es/operator/mergeAll' {
export * from '~rxjs-es/operator/mergeAll';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/mergeAll.d.ts
declare module '~rxjs-es/add/operator/mergeAll' {
import { MergeAllSignature } from '~rxjs-es/operator/mergeAll';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        mergeAll: MergeAllSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/mergeMap.d.ts
declare module '~rxjs-es/operator/mergeMap' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
import { OuterSubscriber } from '~rxjs-es/OuterSubscriber';
import { InnerSubscriber } from '~rxjs-es/InnerSubscriber';
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
export function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number, concurrent?: number): Observable<R>;
export interface MergeMapSignature<T> {
    <R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): Observable<R>;
    <I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): Observable<R>;
}
export class MergeMapOperator<T, I, R> implements Operator<T, I> {
    private project;
    private resultSelector;
    private concurrent;
    constructor(project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number);
    call(observer: Subscriber<I>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class MergeMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {
    private project;
    private resultSelector;
    private concurrent;
    private hasCompleted;
    private buffer;
    private active;
    protected index: number;
    constructor(destination: Subscriber<I>, project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number);
    protected _next(value: T): void;
    protected _tryNext(value: T): void;
    private _innerSub(ish, value, index);
    protected _complete(): void;
    notifyNext(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, I>): void;
    private _notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
    notifyComplete(innerSub: Subscription): void;
}
}
declare module 'rxjs-es/operator/mergeMap' {
export * from '~rxjs-es/operator/mergeMap';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/mergeMap.d.ts
declare module '~rxjs-es/add/operator/mergeMap' {
import { MergeMapSignature } from '~rxjs-es/operator/mergeMap';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        flatMap: MergeMapSignature<T>;
        mergeMap: MergeMapSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/mergeMapTo.d.ts
declare module '~rxjs-es/operator/mergeMapTo' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
import { OuterSubscriber } from '~rxjs-es/OuterSubscriber';
import { InnerSubscriber } from '~rxjs-es/InnerSubscriber';
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in the output Observable.
 *
 * <span class="informal">It's like {@link mergeMap}, but maps each value always
 * to the same inner Observable.</span>
 *
 * <img src="./img/mergeMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then merges those resulting Observables into one
 * single Observable, which is the output Observable.
 *
 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 * @see {@link switchMapTo}
 *
 * @param {Observable} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable.
 * @method mergeMapTo
 * @owner Observable
 */
export function mergeMapTo<T, I, R>(innerObservable: Observable<I>, resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number, concurrent?: number): Observable<R>;
export interface MergeMapToSignature<T> {
    <R>(observable: ObservableInput<R>, concurrent?: number): Observable<R>;
    <I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): Observable<R>;
}
export class MergeMapToOperator<T, I, R> implements Operator<Observable<T>, R> {
    private ish;
    private resultSelector;
    private concurrent;
    constructor(ish: ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number);
    call(observer: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class MergeMapToSubscriber<T, I, R> extends OuterSubscriber<T, I> {
    private ish;
    private resultSelector;
    private concurrent;
    private hasCompleted;
    private buffer;
    private active;
    protected index: number;
    constructor(destination: Subscriber<R>, ish: ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number);
    protected _next(value: T): void;
    private _innerSub(ish, destination, resultSelector, value, index);
    protected _complete(): void;
    notifyNext(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, I>): void;
    private trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
    notifyError(err: any): void;
    notifyComplete(innerSub: Subscription): void;
}
}
declare module 'rxjs-es/operator/mergeMapTo' {
export * from '~rxjs-es/operator/mergeMapTo';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/mergeMapTo.d.ts
declare module '~rxjs-es/add/operator/mergeMapTo' {
import { MergeMapToSignature } from '~rxjs-es/operator/mergeMapTo';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        flatMapTo: MergeMapToSignature<T>;
        mergeMapTo: MergeMapToSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/mergeScan.d.ts
declare module '~rxjs-es/operator/mergeScan' {
import { Operator } from '~rxjs-es/Operator';
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
import { OuterSubscriber } from '~rxjs-es/OuterSubscriber';
import { InnerSubscriber } from '~rxjs-es/InnerSubscriber';
/**
 * @param project
 * @param seed
 * @param concurrent
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method mergeScan
 * @owner Observable
 */
export function mergeScan<T, R>(project: (acc: R, value: T) => Observable<R>, seed: R, concurrent?: number): Observable<R>;
export interface MergeScanSignature<T> {
    <R>(project: (acc: R, value: T) => Observable<R>, seed: R, concurrent?: number): Observable<R>;
}
export class MergeScanOperator<T, R> implements Operator<T, R> {
    private project;
    private seed;
    private concurrent;
    constructor(project: (acc: R, value: T) => Observable<R>, seed: R, concurrent: number);
    call(subscriber: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class MergeScanSubscriber<T, R> extends OuterSubscriber<T, R> {
    private project;
    private acc;
    private concurrent;
    private hasValue;
    private hasCompleted;
    private buffer;
    private active;
    protected index: number;
    constructor(destination: Subscriber<R>, project: (acc: R, value: T) => Observable<R>, acc: R, concurrent: number);
    protected _next(value: any): void;
    private _innerSub(ish, value, index);
    protected _complete(): void;
    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
    notifyComplete(innerSub: Subscription): void;
}
}
declare module 'rxjs-es/operator/mergeScan' {
export * from '~rxjs-es/operator/mergeScan';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/mergeScan.d.ts
declare module '~rxjs-es/add/operator/mergeScan' {
import { MergeScanSignature } from '~rxjs-es/operator/mergeScan';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        mergeScan: MergeScanSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/min.d.ts
declare module '~rxjs-es/operator/min' {
import { Observable } from '~rxjs-es/Observable';
/**
 * The Min operator operates on an Observable that emits numbers (or items that can be evaluated as numbers),
 * and when source Observable completes it emits a single item: the item with the smallest number.
 *
 * <img src="./img/min.png" width="100%">
 *
 * @param {Function} optional comparer function that it will use instead of its default to compare the value of two items.
 * @return {Observable<R>} an Observable that emits item with the smallest number.
 * @method min
 * @owner Observable
 */
export function min<T>(comparer?: (x: T, y: T) => number): Observable<T>;
export interface MinSignature<T> {
    (comparer?: (x: T, y: T) => number): Observable<T>;
}
}
declare module 'rxjs-es/operator/min' {
export * from '~rxjs-es/operator/min';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/min.d.ts
declare module '~rxjs-es/add/operator/min' {
import { MinSignature } from '~rxjs-es/operator/min';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        min: MinSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/multicast.d.ts
declare module '~rxjs-es/operator/multicast' {
import { Subject } from '~rxjs-es/Subject';
import { Observable } from '~rxjs-es/Observable';
import { ConnectableObservable } from '~rxjs-es/observable/ConnectableObservable';
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} an Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
export function multicast<T>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>), selector?: (source: Observable<T>) => Observable<T>): Observable<T> | ConnectableObservable<T>;
export type factoryOrValue<T> = T | (() => T);
export type selector<T> = (source: Observable<T>) => Observable<T>;
export interface MulticastSignature<T> {
    (subjectOrSubjectFactory: factoryOrValue<Subject<T>>): ConnectableObservable<T>;
    (SubjectFactory: () => Subject<T>, selector?: selector<T>): Observable<T>;
}
}
declare module 'rxjs-es/operator/multicast' {
export * from '~rxjs-es/operator/multicast';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/multicast.d.ts
declare module '~rxjs-es/add/operator/multicast' {
import { MulticastSignature } from '~rxjs-es/operator/multicast';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        multicast: MulticastSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/observeOn.d.ts
declare module '~rxjs-es/operator/observeOn' {
import { Observable } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
import { Operator } from '~rxjs-es/Operator';
import { PartialObserver } from '~rxjs-es/Observer';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Notification } from '~rxjs-es/Notification';
import { TeardownLogic } from '~rxjs-es/Subscription';
/**
 * @see {@link Notification}
 *
 * @param scheduler
 * @param delay
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method observeOn
 * @owner Observable
 */
export function observeOn<T>(scheduler: Scheduler, delay?: number): Observable<T>;
export interface ObserveOnSignature<T> {
    (scheduler: Scheduler, delay?: number): Observable<T>;
}
export class ObserveOnOperator<T> implements Operator<T, T> {
    private scheduler;
    private delay;
    constructor(scheduler: Scheduler, delay?: number);
    call(subscriber: Subscriber<T>, source: any): TeardownLogic;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class ObserveOnSubscriber<T> extends Subscriber<T> {
    private scheduler;
    private delay;
    static dispatch(arg: ObserveOnMessage): void;
    constructor(destination: Subscriber<T>, scheduler: Scheduler, delay?: number);
    private scheduleMessage(notification);
    protected _next(value: T): void;
    protected _error(err: any): void;
    protected _complete(): void;
}
export class ObserveOnMessage {
    notification: Notification<any>;
    destination: PartialObserver<any>;
    constructor(notification: Notification<any>, destination: PartialObserver<any>);
}
}
declare module 'rxjs-es/operator/observeOn' {
export * from '~rxjs-es/operator/observeOn';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/observeOn.d.ts
declare module '~rxjs-es/add/operator/observeOn' {
import { ObserveOnSignature } from '~rxjs-es/operator/observeOn';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        observeOn: ObserveOnSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/onErrorResumeNext.d.ts
declare module '~rxjs-es/add/operator/onErrorResumeNext' {
import { OnErrorResumeNextSignature } from '~rxjs-es/operator/onErrorResumeNext';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        onErrorResumeNext: OnErrorResumeNextSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/pairwise.d.ts
declare module '~rxjs-es/operator/pairwise' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
export function pairwise<T>(): Observable<[T, T]>;
export interface PairwiseSignature<T> {
    (): Observable<[T, T]>;
}
}
declare module 'rxjs-es/operator/pairwise' {
export * from '~rxjs-es/operator/pairwise';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/pairwise.d.ts
declare module '~rxjs-es/add/operator/pairwise' {
import { PairwiseSignature } from '~rxjs-es/operator/pairwise';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        pairwise: PairwiseSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/partition.d.ts
declare module '~rxjs-es/operator/partition' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Splits the source Observable into two, one with values that satisfy a
 * predicate, and another with values that don't satisfy the predicate.
 *
 * <span class="informal">It's like {@link filter}, but returns two Observables:
 * one like the output of {@link filter}, and the other with values that did not
 * pass the condition.</span>
 *
 * <img src="./img/partition.png" width="100%">
 *
 * `partition` outputs an array with two Observables that partition the values
 * from the source Observable through the given `predicate` function. The first
 * Observable in that array emits source values for which the predicate argument
 * returns true. The second Observable emits source values for which the
 * predicate returns false. The first behaves like {@link filter} and the second
 * behaves like {@link filter} with the predicate negated.
 *
 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
 * var clicksOnDivs = parts[0];
 * var clicksElsewhere = parts[1];
 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
 *
 * @see {@link filter}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted on the first Observable in the returned array, if
 * `false` the value is emitted on the second Observable in the array. The
 * `index` parameter is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
 * with values that passed the predicate, and another with values that did not
 * pass the predicate.
 * @method partition
 * @owner Observable
 */
export function partition<T>(predicate: (value: T) => boolean, thisArg?: any): [Observable<T>, Observable<T>];
export interface PartitionSignature<T> {
    (predicate: (value: T) => boolean, thisArg?: any): [Observable<T>, Observable<T>];
}
}
declare module 'rxjs-es/operator/partition' {
export * from '~rxjs-es/operator/partition';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/partition.d.ts
declare module '~rxjs-es/add/operator/partition' {
import { PartitionSignature } from '~rxjs-es/operator/partition';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        partition: PartitionSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/pluck.d.ts
declare module '~rxjs-es/operator/pluck' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Maps each source value (an object) to its specified nested property.
 *
 * <span class="informal">Like {@link map}, but meant only for picking one of
 * the nested properties of every emitted object.</span>
 *
 * <img src="./img/pluck.png" width="100%">
 *
 * Given a list of strings describing a path to an object property, retrieves
 * the value of a specified nested property from all values in the source
 * Observable. If a property can't be resolved, it will return `undefined` for
 * that value.
 *
 * @example <caption>Map every every click to the tagName of the clicked target element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var tagNames = clicks.pluck('target', 'tagName');
 * tagNames.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {...string} properties The nested properties to pluck from each source
 * value (an object).
 * @return {Observable} Returns a new Observable of property values from the
 * source values.
 * @method pluck
 * @owner Observable
 */
export function pluck<R>(...properties: string[]): Observable<R>;
export interface PluckSignature<T> {
    <R>(...properties: string[]): Observable<R>;
}
}
declare module 'rxjs-es/operator/pluck' {
export * from '~rxjs-es/operator/pluck';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/pluck.d.ts
declare module '~rxjs-es/add/operator/pluck' {
import { PluckSignature } from '~rxjs-es/operator/pluck';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        pluck: PluckSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/publish.d.ts
declare module '~rxjs-es/operator/publish' {
import { Observable } from '~rxjs-es/Observable';
import { ConnectableObservable } from '~rxjs-es/observable/ConnectableObservable';
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} Optional selector function which can use the multicasted source sequence as many times as needed,
 * without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return a ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
export function publish<T>(selector?: (source: Observable<T>) => Observable<T>): Observable<T> | ConnectableObservable<T>;
export type selector<T> = (source: Observable<T>) => Observable<T>;
export interface PublishSignature<T> {
    (): ConnectableObservable<T>;
    (selector: selector<T>): Observable<T>;
}
}
declare module 'rxjs-es/operator/publish' {
export * from '~rxjs-es/operator/publish';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/publish.d.ts
declare module '~rxjs-es/add/operator/publish' {
import { PublishSignature } from '~rxjs-es/operator/publish';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        publish: PublishSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/publishBehavior.d.ts
declare module '~rxjs-es/operator/publishBehavior' {
import { ConnectableObservable } from '~rxjs-es/observable/ConnectableObservable';
/**
 * @param value
 * @return {ConnectableObservable<T>}
 * @method publishBehavior
 * @owner Observable
 */
export function publishBehavior<T>(value: T): ConnectableObservable<T>;
export interface PublishBehaviorSignature<T> {
    (value: T): ConnectableObservable<T>;
}
}
declare module 'rxjs-es/operator/publishBehavior' {
export * from '~rxjs-es/operator/publishBehavior';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/publishBehavior.d.ts
declare module '~rxjs-es/add/operator/publishBehavior' {
import { PublishBehaviorSignature } from '~rxjs-es/operator/publishBehavior';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        publishBehavior: PublishBehaviorSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/publishReplay.d.ts
declare module '~rxjs-es/operator/publishReplay' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { ConnectableObservable } from '~rxjs-es/observable/ConnectableObservable';
/**
 * @param bufferSize
 * @param windowTime
 * @param scheduler
 * @return {ConnectableObservable<T>}
 * @method publishReplay
 * @owner Observable
 */
export function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: Scheduler): ConnectableObservable<T>;
export interface PublishReplaySignature<T> {
    (bufferSize?: number, windowTime?: number, scheduler?: Scheduler): ConnectableObservable<T>;
}
}
declare module 'rxjs-es/operator/publishReplay' {
export * from '~rxjs-es/operator/publishReplay';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/publishReplay.d.ts
declare module '~rxjs-es/add/operator/publishReplay' {
import { PublishReplaySignature } from '~rxjs-es/operator/publishReplay';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        publishReplay: PublishReplaySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/publishLast.d.ts
declare module '~rxjs-es/operator/publishLast' {
import { ConnectableObservable } from '~rxjs-es/observable/ConnectableObservable';
/**
 * @return {ConnectableObservable<T>}
 * @method publishLast
 * @owner Observable
 */
export function publishLast<T>(): ConnectableObservable<T>;
export interface PublishLastSignature<T> {
    (): ConnectableObservable<T>;
}
}
declare module 'rxjs-es/operator/publishLast' {
export * from '~rxjs-es/operator/publishLast';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/publishLast.d.ts
declare module '~rxjs-es/add/operator/publishLast' {
import { PublishLastSignature } from '~rxjs-es/operator/publishLast';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        publishLast: PublishLastSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/race.d.ts
declare module '~rxjs-es/add/operator/race' {
import { RaceSignature } from '~rxjs-es/operator/race';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        race: RaceSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/reduce.d.ts
declare module '~rxjs-es/operator/reduce' {
import { Observable } from '~rxjs-es/Observable';
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
/**
 * Applies an accumulator function over the source Observable, and returns the
 * accumulated result when the source completes, given an optional seed value.
 *
 * <span class="informal">Combines together all values emitted on the source,
 * using an accumulator function that knows how to join a new source value into
 * the accumulation from the past.</span>
 *
 * <img src="./img/reduce.png" width="100%">
 *
 * Like
 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
 * `reduce` applies an `accumulator` function against an accumulation and each
 * value of the source Observable (from the past) to reduce it to a single
 * value, emitted on the output Observable. Note that `reduce` will only emit
 * one value, only when the source Observable completes. It is equivalent to
 * applying operator {@link scan} followed by operator {@link last}.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
 *   .takeUntil(Rx.Observable.interval(5000));
 * var ones = clicksInFiveSeconds.mapTo(1);
 * var seed = 0;
 * var count = ones.reduce((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link count}
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link scan}
 *
 * @param {function(acc: R, value: T): R} accumulator The accumulator function
 * called on each source value.
 * @param {R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @return {Observable<R>} An Observable that emits a single value that is the
 * result of accumulating the values emitted by the source Observable.
 * @method reduce
 * @owner Observable
 */
export function reduce<T, R>(accumulator: (acc: R, value: T) => R, seed?: R): Observable<R>;
export interface ReduceSignature<T> {
    (accumulator: (acc: T, value: T, index: number) => T, seed?: T): Observable<T>;
    (accumulator: (acc: T[], value: T, index: number) => T[], seed?: T[]): Observable<T[]>;
    <R>(accumulator: (acc: R, value: T, index: number) => R, seed?: R): Observable<R>;
}
export class ReduceOperator<T, R> implements Operator<T, R> {
    private accumulator;
    private seed;
    constructor(accumulator: (acc: R, value: T) => R, seed?: R);
    call(subscriber: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class ReduceSubscriber<T, R> extends Subscriber<T> {
    private accumulator;
    acc: T | R;
    hasSeed: boolean;
    hasValue: boolean;
    constructor(destination: Subscriber<R>, accumulator: (acc: R, value: T) => R, seed?: R);
    protected _next(value: T): void;
    private _tryReduce(value);
    protected _complete(): void;
}
}
declare module 'rxjs-es/operator/reduce' {
export * from '~rxjs-es/operator/reduce';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/reduce.d.ts
declare module '~rxjs-es/add/operator/reduce' {
import { ReduceSignature } from '~rxjs-es/operator/reduce';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        reduce: ReduceSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/repeat.d.ts
declare module '~rxjs-es/operator/repeat' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times,
 * on a particular Scheduler.
 *
 * <img src="./img/repeat.png" width="100%">
 *
 * @param {Scheduler} [scheduler] the Scheduler to emit the items on.
 * @param {number} [count] the number of times the source Observable items are repeated, a count of 0 will yield
 * an empty Observable.
 * @return {Observable} an Observable that repeats the stream of items emitted by the source Observable at most
 * count times.
 * @method repeat
 * @owner Observable
 */
export function repeat<T>(count?: number): Observable<T>;
export interface RepeatSignature<T> {
    (count?: number): Observable<T>;
}
}
declare module 'rxjs-es/operator/repeat' {
export * from '~rxjs-es/operator/repeat';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/repeat.d.ts
declare module '~rxjs-es/add/operator/repeat' {
import { RepeatSignature } from '~rxjs-es/operator/repeat';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        repeat: RepeatSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/repeatWhen.d.ts
declare module '~rxjs-es/operator/repeatWhen' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that emits the same values as the source observable with the exception of a `complete`.
 * A `complete` will cause the emission of the Throwable that cause the complete to the Observable returned from
 * notificationHandler. If that Observable calls onComplete or `complete` then retry will call `complete` or `error`
 * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a particular
 * Scheduler.
 *
 * <img src="./img/repeatWhen.png" width="100%">
 *
 * @param {notificationHandler} receives an Observable of notifications with which a user can `complete` or `error`,
 * aborting the retry.
 * @param {scheduler} the Scheduler on which to subscribe to the source Observable.
 * @return {Observable} the source Observable modified with retry logic.
 * @method repeatWhen
 * @owner Observable
 */
export function repeatWhen<T>(notifier: (notifications: Observable<any>) => Observable<any>): Observable<T>;
export interface RepeatWhenSignature<T> {
    (notifier: (notifications: Observable<any>) => Observable<any>): Observable<T>;
}
}
declare module 'rxjs-es/operator/repeatWhen' {
export * from '~rxjs-es/operator/repeatWhen';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/repeatWhen.d.ts
declare module '~rxjs-es/add/operator/repeatWhen' {
import { RepeatWhenSignature } from '~rxjs-es/operator/repeatWhen';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        repeatWhen: RepeatWhenSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/retry.d.ts
declare module '~rxjs-es/operator/retry' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that mirrors the source Observable, resubscribing to it if it calls `error` and the
 * predicate returns true for that specific exception and retry count.
 * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of
 * count resubscriptions (given as a number parameter) rather than propagating the `error` call.
 *
 * <img src="./img/retry.png" width="100%">
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 * @param {number} number of retry attempts before failing.
 * @return {Observable} the source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */
export function retry<T>(count?: number): Observable<T>;
export interface RetrySignature<T> {
    (count?: number): Observable<T>;
}
}
declare module 'rxjs-es/operator/retry' {
export * from '~rxjs-es/operator/retry';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/retry.d.ts
declare module '~rxjs-es/add/operator/retry' {
import { RetrySignature } from '~rxjs-es/operator/retry';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        retry: RetrySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/retryWhen.d.ts
declare module '~rxjs-es/operator/retryWhen' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that emits the same values as the source observable with the exception of an `error`.
 * An `error` will cause the emission of the Throwable that cause the error to the Observable returned from
 * notificationHandler. If that Observable calls onComplete or `error` then retry will call `complete` or `error`
 * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a particular
 * Scheduler.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {notificationHandler} receives an Observable of notifications with which a user can `complete` or `error`,
 * aborting the retry.
 * @param {scheduler} the Scheduler on which to subscribe to the source Observable.
 * @return {Observable} the source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */
export function retryWhen<T>(notifier: (errors: Observable<any>) => Observable<any>): Observable<T>;
export interface RetryWhenSignature<T> {
    (notifier: (errors: Observable<any>) => Observable<any>): Observable<T>;
}
}
declare module 'rxjs-es/operator/retryWhen' {
export * from '~rxjs-es/operator/retryWhen';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/retryWhen.d.ts
declare module '~rxjs-es/add/operator/retryWhen' {
import { RetryWhenSignature } from '~rxjs-es/operator/retryWhen';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        retryWhen: RetryWhenSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/sample.d.ts
declare module '~rxjs-es/operator/sample' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits the most recently emitted value from the source Observable whenever
 * another Observable, the `notifier`, emits.
 *
 * <span class="informal">It's like {@link sampleTime}, but samples whenever
 * the `notifier` Observable emits something.</span>
 *
 * <img src="./img/sample.png" width="100%">
 *
 * Whenever the `notifier` Observable emits a value or completes, `sample`
 * looks at the source Observable and emits whichever value it has most recently
 * emitted since the previous sampling, unless the source has not emitted
 * anything since the previous sampling. The `notifier` is subscribed to as soon
 * as the output Observable is subscribed.
 *
 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = seconds.sample(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {Observable<any>} notifier The Observable to use for sampling the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable whenever the notifier Observable
 * emits value or completes.
 * @method sample
 * @owner Observable
 */
export function sample<T>(notifier: Observable<any>): Observable<T>;
export interface SampleSignature<T> {
    (notifier: Observable<any>): Observable<T>;
}
}
declare module 'rxjs-es/operator/sample' {
export * from '~rxjs-es/operator/sample';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/sample.d.ts
declare module '~rxjs-es/add/operator/sample' {
import { SampleSignature } from '~rxjs-es/operator/sample';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        sample: SampleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/sampleTime.d.ts
declare module '~rxjs-es/operator/sampleTime' {
import { Observable } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
/**
 * Emits the most recently emitted value from the source Observable within
 * periodic time intervals.
 *
 * <span class="informal">Samples the source Observable at periodic time
 * intervals, emitting what it samples.</span>
 *
 * <img src="./img/sampleTime.png" width="100%">
 *
 * `sampleTime` periodically looks at the source Observable and emits whichever
 * value it has most recently emitted since the previous sampling, unless the
 * source has not emitted anything since the previous sampling. The sampling
 * happens periodically in time every `period` milliseconds (or the time unit
 * defined by the optional `scheduler` argument). The sampling starts as soon as
 * the output Observable is subscribed.
 *
 * @example <caption>Every second, emit the most recent click at most once</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.sampleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {number} period The sampling period expressed in milliseconds or the
 * time unit determined internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable at the specified time interval.
 * @method sampleTime
 * @owner Observable
 */
export function sampleTime<T>(period: number, scheduler?: Scheduler): Observable<T>;
export interface SampleTimeSignature<T> {
    (period: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module 'rxjs-es/operator/sampleTime' {
export * from '~rxjs-es/operator/sampleTime';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/sampleTime.d.ts
declare module '~rxjs-es/add/operator/sampleTime' {
import { SampleTimeSignature } from '~rxjs-es/operator/sampleTime';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        sampleTime: SampleTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/scan.d.ts
declare module '~rxjs-es/add/operator/scan' {
import { ReduceSignature } from '~rxjs-es/operator/reduce';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        scan: ReduceSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/sequenceEqual.d.ts
declare module '~rxjs-es/operator/sequenceEqual' {
import { Operator } from '~rxjs-es/Operator';
import { Observer } from '~rxjs-es/Observer';
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
export interface SequenceEqualSignature<T> {
    (compareTo: Observable<T>, comparor?: (a: T, b: T) => boolean): Observable<boolean>;
}
/**
 * Compares all values of two observables in sequence using an optional comparor function
 * and returns an observable of a single boolean value representing whether or not the two sequences
 * are equal.
 *
 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
 *
 * <img src="./img/sequenceEqual.png" width="100%">
 *
 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
 * observables completes, the operator will wait for the other observable to complete; If the other
 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
 * completes or emits after the other complets, the returned observable will never complete.
 *
 * @example <caption>figure out if the Konami code matches</caption>
 * var code = Observable.from([
 *  "ArrowUp",
 *  "ArrowUp",
 *  "ArrowDown",
 *  "ArrowDown",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "KeyB",
 *  "KeyA",
 *  "Enter" // no start key, clearly.
 * ]);
 *
 * var keys = Rx.Observable.fromEvent(document, 'keyup')
 *  .map(e => e.code);
 * var matches = keys.bufferCount(11, 1)
 *  .mergeMap(
 *    last11 =>
 *      Rx.Observable.from(last11)
 *        .sequenceEqual(code)
 *   );
 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} compareTo the observable sequence to compare the source sequence to.
 * @param {function} [comparor] An optional function to compare each value pair
 * @return {Observable} An Observable of a single boolean value representing whether or not
 * the values emitted by both observables were equal in sequence
 * @method sequenceEqual
 * @owner Observable
 */
export function sequenceEqual<T>(compareTo: Observable<T>, comparor?: (a: T, b: T) => boolean): Observable<boolean>;
export class SequenceEqualOperator<T> implements Operator<T, T> {
    private compareTo;
    private comparor;
    constructor(compareTo: Observable<T>, comparor: (a: T, b: T) => boolean);
    call(subscriber: Subscriber<T>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class SequenceEqualSubscriber<T, R> extends Subscriber<T> {
    private compareTo;
    private comparor;
    private _a;
    private _b;
    private _oneComplete;
    constructor(destination: Observer<R>, compareTo: Observable<T>, comparor: (a: T, b: T) => boolean);
    protected _next(value: T): void;
    _complete(): void;
    checkValues(): void;
    emit(value: boolean): void;
    nextB(value: T): void;
}
}
declare module 'rxjs-es/operator/sequenceEqual' {
export * from '~rxjs-es/operator/sequenceEqual';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/sequenceEqual.d.ts
declare module '~rxjs-es/add/operator/sequenceEqual' {
import { SequenceEqualSignature } from '~rxjs-es/operator/sequenceEqual';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        sequenceEqual: SequenceEqualSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/share.d.ts
declare module '~rxjs-es/operator/share' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .publish().refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} an Observable that upon connection causes the source Observable to emit items to its Observers
 * @method share
 * @owner Observable
 */
export function share<T>(): Observable<T>;
export interface ShareSignature<T> {
    (): Observable<T>;
}
}
declare module 'rxjs-es/operator/share' {
export * from '~rxjs-es/operator/share';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/share.d.ts
declare module '~rxjs-es/add/operator/share' {
import { ShareSignature } from '~rxjs-es/operator/share';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        share: ShareSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/single.d.ts
declare module '~rxjs-es/operator/single' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
 *
 * <img src="./img/single.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {Function} a predicate function to evaluate items emitted by the source Observable.
 * @return {Observable<T>} an Observable that emits the single item emitted by the source Observable that matches
 * the predicate.
 .
 * @method single
 * @owner Observable
 */
export function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<T>;
export interface SingleSignature<T> {
    (predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<T>;
}
}
declare module 'rxjs-es/operator/single' {
export * from '~rxjs-es/operator/single';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/single.d.ts
declare module '~rxjs-es/add/operator/single' {
import { SingleSignature } from '~rxjs-es/operator/single';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        single: SingleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/skip.d.ts
declare module '~rxjs-es/operator/skip' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that skips `n` items emitted by an Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} the `n` of times, items emitted by source Observable should be skipped.
 * @return {Observable} an Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
export function skip<T>(total: number): Observable<T>;
export interface SkipSignature<T> {
    (total: number): Observable<T>;
}
}
declare module 'rxjs-es/operator/skip' {
export * from '~rxjs-es/operator/skip';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/skip.d.ts
declare module '~rxjs-es/add/operator/skip' {
import { SkipSignature } from '~rxjs-es/operator/skip';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        skip: SkipSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/skipUntil.d.ts
declare module '~rxjs-es/operator/skipUntil' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} the second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} an Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
export function skipUntil<T>(notifier: Observable<any>): Observable<T>;
export interface SkipUntilSignature<T> {
    (notifier: Observable<any>): Observable<T>;
}
}
declare module 'rxjs-es/operator/skipUntil' {
export * from '~rxjs-es/operator/skipUntil';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/skipUntil.d.ts
declare module '~rxjs-es/add/operator/skipUntil' {
import { SkipUntilSignature } from '~rxjs-es/operator/skipUntil';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        skipUntil: SkipUntilSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/skipWhile.d.ts
declare module '~rxjs-es/operator/skipWhile' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - a function to test each item emitted from the source Observable.
 * @return {Observable<T>} an Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
export function skipWhile<T>(predicate: (value: T, index: number) => boolean): Observable<T>;
export interface SkipWhileSignature<T> {
    (predicate: (value: T, index: number) => boolean): Observable<T>;
}
}
declare module 'rxjs-es/operator/skipWhile' {
export * from '~rxjs-es/operator/skipWhile';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/skipWhile.d.ts
declare module '~rxjs-es/add/operator/skipWhile' {
import { SkipWhileSignature } from '~rxjs-es/operator/skipWhile';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        skipWhile: SkipWhileSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/startWith.d.ts
declare module '~rxjs-es/operator/startWith' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
/**
 * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the
 * source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.
 * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
export function startWith<T>(...array: Array<T | Scheduler>): Observable<T>;
export interface StartWithSignature<T> {
    (v1: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, v3: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, v3: T, v4: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, v3: T, v4: T, v5: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, scheduler?: Scheduler): Observable<T>;
    (...array: Array<T | Scheduler>): Observable<T>;
}
}
declare module 'rxjs-es/operator/startWith' {
export * from '~rxjs-es/operator/startWith';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/startWith.d.ts
declare module '~rxjs-es/add/operator/startWith' {
import { StartWithSignature } from '~rxjs-es/operator/startWith';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        startWith: StartWithSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/subscribeOn.d.ts
declare module '~rxjs-es/operator/subscribeOn' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
/**
 * Asynchronously subscribes Observers to this Observable on the specified Scheduler.
 *
 * <img src="./img/subscribeOn.png" width="100%">
 *
 * @param {Scheduler} the Scheduler to perform subscription actions on.
 * @return {Observable<T>} the source Observable modified so that its subscriptions happen on the specified Scheduler
 .
 * @method subscribeOn
 * @owner Observable
 */
export function subscribeOn<T>(scheduler: Scheduler, delay?: number): Observable<T>;
export interface SubscribeOnSignature<T> {
    (scheduler: Scheduler, delay?: number): Observable<T>;
}
}
declare module 'rxjs-es/operator/subscribeOn' {
export * from '~rxjs-es/operator/subscribeOn';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/subscribeOn.d.ts
declare module '~rxjs-es/add/operator/subscribeOn' {
import { SubscribeOnSignature } from '~rxjs-es/operator/subscribeOn';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        subscribeOn: SubscribeOnSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/switch.d.ts
declare module '~rxjs-es/operator/switch' {
/**
 * Converts a higher-order Observable into a first-order Observable by
 * subscribing to only the most recently emitted of those inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * previous inner Observable once a new one appears.</span>
 *
 * <img src="./img/switch.png" width="100%">
 *
 * `switch` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable subscribes to the inner Observable and
 * begins emitting the items emitted by that. So far, it behaves
 * like {@link mergeAll}. However, when a new inner Observable is emitted,
 * `switch` unsubscribes from the earlier-emitted inner Observable and
 * subscribes to the new inner Observable and begins emitting items from it. It
 * continues to behave like this for subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * // Each click event is mapped to an Observable that ticks every second
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var switched = higherOrder.switch();
 * // The outcome is that `switched` is essentially a timer that restarts
 * // on every click. The interval Observables from older clicks do not merge
 * // with the current interval Observable.
 * switched.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switchMap}
 * @see {@link switchMapTo}
 * @see {@link zipAll}
 *
 * @return {Observable<T>} An Observable that emits the items emitted by the
 * Observable most recently emitted by the source Observable.
 * @method switch
 * @name switch
 * @owner Observable
 */
export function _switch<T>(): T;
export interface SwitchSignature<T> {
    (): T;
}
}
declare module 'rxjs-es/operator/switch' {
export * from '~rxjs-es/operator/switch';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/switch.d.ts
declare module '~rxjs-es/add/operator/switch' {
import { SwitchSignature } from '~rxjs-es/operator/switch';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        switch: SwitchSignature<T>;
        _switch: SwitchSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/switchMap.d.ts
declare module '~rxjs-es/operator/switchMap' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
export function switchMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
export interface SwitchMapSignature<T> {
    <R>(project: (value: T, index: number) => ObservableInput<R>): Observable<R>;
    <I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
}
}
declare module 'rxjs-es/operator/switchMap' {
export * from '~rxjs-es/operator/switchMap';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/switchMap.d.ts
declare module '~rxjs-es/add/operator/switchMap' {
import { SwitchMapSignature } from '~rxjs-es/operator/switchMap';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        switchMap: SwitchMapSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/switchMapTo.d.ts
declare module '~rxjs-es/operator/switchMapTo' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {Observable} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` every time a value is emitted on the source Observable.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
export function switchMapTo<T, I, R>(innerObservable: Observable<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
export interface SwitchMapToSignature<T> {
    <R>(observable: ObservableInput<R>): Observable<R>;
    <I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
}
}
declare module 'rxjs-es/operator/switchMapTo' {
export * from '~rxjs-es/operator/switchMapTo';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/switchMapTo.d.ts
declare module '~rxjs-es/add/operator/switchMapTo' {
import { SwitchMapToSignature } from '~rxjs-es/operator/switchMapTo';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        switchMapTo: SwitchMapToSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/take.d.ts
declare module '~rxjs-es/operator/take' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
export function take<T>(count: number): Observable<T>;
export interface TakeSignature<T> {
    (count: number): Observable<T>;
}
}
declare module 'rxjs-es/operator/take' {
export * from '~rxjs-es/operator/take';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/take.d.ts
declare module '~rxjs-es/add/operator/take' {
import { TakeSignature } from '~rxjs-es/operator/take';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        take: TakeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/takeLast.d.ts
declare module '~rxjs-es/operator/takeLast' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits only the last `count` values emitted by the source Observable.
 *
 * <span class="informal">Remembers the latest `count` values, then emits those
 * only when the source completes.</span>
 *
 * <img src="./img/takeLast.png" width="100%">
 *
 * `takeLast` returns an Observable that emits at most the last `count` values
 * emitted by the source Observable. If the source emits fewer than `count`
 * values then all of its values are emitted. This operator must wait until the
 * `complete` notification emission from the source in order to emit the `next`
 * values on the output Observable, because otherwise it is impossible to know
 * whether or not more values will be emitted on the source. For this reason,
 * all values are emitted synchronously, followed by the complete notification.
 *
 * @example <caption>Take the last 3 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 100);
 * var lastThree = many.takeLast(3);
 * lastThree.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of values to emit from the end of
 * the sequence of values emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits at most the last count
 * values emitted by the source Observable.
 * @method takeLast
 * @owner Observable
 */
export function takeLast<T>(count: number): Observable<T>;
export interface TakeLastSignature<T> {
    (count: number): Observable<T>;
}
}
declare module 'rxjs-es/operator/takeLast' {
export * from '~rxjs-es/operator/takeLast';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/takeLast.d.ts
declare module '~rxjs-es/add/operator/takeLast' {
import { TakeLastSignature } from '~rxjs-es/operator/takeLast';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        takeLast: TakeLastSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/takeUntil.d.ts
declare module '~rxjs-es/operator/takeUntil' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
export function takeUntil<T>(notifier: Observable<any>): Observable<T>;
export interface TakeUntilSignature<T> {
    (notifier: Observable<any>): Observable<T>;
}
}
declare module 'rxjs-es/operator/takeUntil' {
export * from '~rxjs-es/operator/takeUntil';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/takeUntil.d.ts
declare module '~rxjs-es/add/operator/takeUntil' {
import { TakeUntilSignature } from '~rxjs-es/operator/takeUntil';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        takeUntil: TakeUntilSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/takeWhile.d.ts
declare module '~rxjs-es/operator/takeWhile' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits values emitted by the source Observable so long as each value satisfies
 * the given `predicate`, and then completes as soon as this `predicate` is not
 * satisfied.
 *
 * <span class="informal">Takes values from the source only while they pass the
 * condition given. When the first value does not satisfy, it completes.</span>
 *
 * <img src="./img/takeWhile.png" width="100%">
 *
 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
 * emitted on the source is given to the `predicate` function which returns a
 * boolean, representing a condition to be satisfied by the source values. The
 * output Observable emits the source values until such time as the `predicate`
 * returns false, at which point `takeWhile` stops mirroring the source
 * Observable and completes the output Observable.
 *
 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.takeWhile(ev => ev.clientX > 200);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates a value emitted by the source Observable and returns a boolean.
 * Also takes the (zero-based) index as the second argument.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable so long as each value satisfies the condition defined by the
 * `predicate`, then completes.
 * @method takeWhile
 * @owner Observable
 */
export function takeWhile<T>(predicate: (value: T, index: number) => boolean): Observable<T>;
export interface TakeWhileSignature<T> {
    (predicate: (value: T, index: number) => boolean): Observable<T>;
}
}
declare module 'rxjs-es/operator/takeWhile' {
export * from '~rxjs-es/operator/takeWhile';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/takeWhile.d.ts
declare module '~rxjs-es/add/operator/takeWhile' {
import { TakeWhileSignature } from '~rxjs-es/operator/takeWhile';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        takeWhile: TakeWhileSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/throttle.d.ts
declare module '~rxjs-es/operator/throttle' {
import { Observable, SubscribableOrPromise } from '~rxjs-es/Observable';
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): Observable|Promise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */
export function throttle<T>(durationSelector: (value: T) => SubscribableOrPromise<number>): Observable<T>;
export interface ThrottleSignature<T> {
    (durationSelector: (value: T) => SubscribableOrPromise<number>): Observable<T>;
}
}
declare module 'rxjs-es/operator/throttle' {
export * from '~rxjs-es/operator/throttle';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/throttle.d.ts
declare module '~rxjs-es/add/operator/throttle' {
import { ThrottleSignature } from '~rxjs-es/operator/throttle';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        throttle: ThrottleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/throttleTime.d.ts
declare module '~rxjs-es/operator/throttleTime' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link Scheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
export function throttleTime<T>(duration: number, scheduler?: Scheduler): Observable<T>;
export interface ThrottleTimeSignature<T> {
    (duration: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module 'rxjs-es/operator/throttleTime' {
export * from '~rxjs-es/operator/throttleTime';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/throttleTime.d.ts
declare module '~rxjs-es/add/operator/throttleTime' {
import { ThrottleTimeSignature } from '~rxjs-es/operator/throttleTime';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        throttleTime: ThrottleTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/timeInterval.d.ts
declare module '~rxjs-es/add/operator/timeInterval' {
import { TimeIntervalSignature } from '~rxjs-es/operator/timeInterval';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        timeInterval: TimeIntervalSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/timeout.d.ts
declare module '~rxjs-es/operator/timeout' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
/**
 * @param due
 * @param errorToSend
 * @param scheduler
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method timeout
 * @owner Observable
 */
export function timeout<T>(due: number | Date, errorToSend?: any, scheduler?: Scheduler): Observable<T>;
export interface TimeoutSignature<T> {
    (due: number | Date, errorToSend?: any, scheduler?: Scheduler): Observable<T>;
}
}
declare module 'rxjs-es/operator/timeout' {
export * from '~rxjs-es/operator/timeout';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/timeout.d.ts
declare module '~rxjs-es/add/operator/timeout' {
import { TimeoutSignature } from '~rxjs-es/operator/timeout';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        timeout: TimeoutSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/timeoutWith.d.ts
declare module '~rxjs-es/operator/timeoutWith' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable, ObservableInput } from '~rxjs-es/Observable';
/**
 * @param due
 * @param withObservable
 * @param scheduler
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method timeoutWith
 * @owner Observable
 */
export function timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: Scheduler): Observable<T | R>;
export interface TimeoutWithSignature<T> {
    (due: number | Date, withObservable: ObservableInput<T>, scheduler?: Scheduler): Observable<T>;
    <R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: Scheduler): Observable<T | R>;
}
}
declare module 'rxjs-es/operator/timeoutWith' {
export * from '~rxjs-es/operator/timeoutWith';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/timeoutWith.d.ts
declare module '~rxjs-es/add/operator/timeoutWith' {
import { TimeoutWithSignature } from '~rxjs-es/operator/timeoutWith';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        timeoutWith: TimeoutWithSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/timestamp.d.ts
declare module '~rxjs-es/add/operator/timestamp' {
import { TimestampSignature } from '~rxjs-es/operator/timestamp';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        timestamp: TimestampSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/toArray.d.ts
declare module '~rxjs-es/operator/toArray' {
import { Observable } from '~rxjs-es/Observable';
/**
 * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
 * @method toArray
 * @owner Observable
 */
export function toArray<T>(): Observable<T[]>;
export interface ToArraySignature<T> {
    (): Observable<T[]>;
}
}
declare module 'rxjs-es/operator/toArray' {
export * from '~rxjs-es/operator/toArray';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/toArray.d.ts
declare module '~rxjs-es/add/operator/toArray' {
import { ToArraySignature } from '~rxjs-es/operator/toArray';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        toArray: ToArraySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/toPromise.d.ts
declare module '~rxjs-es/operator/toPromise' {
/**
 * @param PromiseCtor
 * @return {Promise<T>}
 * @method toPromise
 * @owner Observable
 */
export function toPromise<T>(PromiseCtor?: typeof Promise): Promise<T>;
export interface ToPromiseSignature<T> {
    (): Promise<T>;
    (PromiseCtor: typeof Promise): Promise<T>;
}
}
declare module 'rxjs-es/operator/toPromise' {
export * from '~rxjs-es/operator/toPromise';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/toPromise.d.ts
declare module '~rxjs-es/add/operator/toPromise' {
import { ToPromiseSignature } from '~rxjs-es/operator/toPromise';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        toPromise: ToPromiseSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/window.d.ts
declare module '~rxjs-es/operator/window' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Branch out the source Observable values as a nested Observable whenever
 * `windowBoundaries` emits.
 *
 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
 * instead of an array.</span>
 *
 * <img src="./img/window.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping
 * windows. It emits the current window and opens a new one whenever the
 * Observable `windowBoundaries` emits an item. Because each window is an
 * Observable, the output is a higher-order Observable.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var result = clicks.window(interval)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link buffer}
 *
 * @param {Observable<any>} windowBoundaries An Observable that completes the
 * previous window and starts a new window.
 * @return {Observable<Observable<T>>} An Observable of windows, which are
 * Observables emitting values of the source Observable.
 * @method window
 * @owner Observable
 */
export function window<T>(windowBoundaries: Observable<any>): Observable<Observable<T>>;
export interface WindowSignature<T> {
    (windowBoundaries: Observable<any>): Observable<Observable<T>>;
}
}
declare module 'rxjs-es/operator/window' {
export * from '~rxjs-es/operator/window';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/window.d.ts
declare module '~rxjs-es/add/operator/window' {
import { WindowSignature } from '~rxjs-es/operator/window';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        window: WindowSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/windowCount.d.ts
declare module '~rxjs-es/operator/windowCount' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Branch out the source Observable values as a nested Observable with each
 * nested Observable emitting at most `windowSize` values.
 *
 * <span class="informal">It's like {@link bufferCount}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowCount.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows every `startWindowEvery`
 * items, each containing no more than `windowSize` items. When the source
 * Observable completes or encounters an error, the output Observable emits
 * the current window and propagates the notification from the source
 * Observable. If `startWindowEvery` is not provided, then new windows are
 * started immediately at the start of the source and when each window completes
 * with size `windowSize`.
 *
 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(3)
 *   .map(win => win.skip(1)) // skip first of every 3 clicks
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(2, 3)
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferCount}
 *
 * @param {number} windowSize The maximum number of values emitted by each
 * window.
 * @param {number} [startWindowEvery] Interval at which to start a new window.
 * For example if `startWindowEvery` is `2`, then a new window will be started
 * on every other value from the source. A new window is started at the
 * beginning of the source by default.
 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
 * are Observable of values.
 * @method windowCount
 * @owner Observable
 */
export function windowCount<T>(windowSize: number, startWindowEvery?: number): Observable<Observable<T>>;
export interface WindowCountSignature<T> {
    (windowSize: number, startWindowEvery?: number): Observable<Observable<T>>;
}
}
declare module 'rxjs-es/operator/windowCount' {
export * from '~rxjs-es/operator/windowCount';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/windowCount.d.ts
declare module '~rxjs-es/add/operator/windowCount' {
import { WindowCountSignature } from '~rxjs-es/operator/windowCount';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        windowCount: WindowCountSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/windowTime.d.ts
declare module '~rxjs-es/operator/windowTime' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Observable } from '~rxjs-es/Observable';
/**
 * Branch out the source Observable values as a nested Observable periodically
 * in time.
 *
 * <span class="informal">It's like {@link bufferTime}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowTime.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable starts a new window periodically, as
 * determined by the `windowCreationInterval` argument. It emits each window
 * after a fixed timespan, specified by the `windowTimeSpan` argument. When the
 * source Observable completes or encounters an error, the output Observable
 * emits the current window and propagates the notification from the source
 * Observable. If `windowCreationInterval` is not provided, the output
 * Observable starts a new window when the previous window of duration
 * `windowTimeSpan` completes.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowTime(1000)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowTime(1000, 5000)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferTime}
 *
 * @param {number} windowTimeSpan The amount of time to fill each window.
 * @param {number} [windowCreationInterval] The interval at which to start new
 * windows.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine window boundaries.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowTime
 * @owner Observable
 */
export function windowTime<T>(windowTimeSpan: number, windowCreationInterval?: number, scheduler?: Scheduler): Observable<Observable<T>>;
export interface WindowTimeSignature<T> {
    (windowTimeSpan: number, windowCreationInterval?: number, scheduler?: Scheduler): Observable<Observable<T>>;
}
}
declare module 'rxjs-es/operator/windowTime' {
export * from '~rxjs-es/operator/windowTime';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/windowTime.d.ts
declare module '~rxjs-es/add/operator/windowTime' {
import { WindowTimeSignature } from '~rxjs-es/operator/windowTime';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        windowTime: WindowTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/windowToggle.d.ts
declare module '~rxjs-es/operator/windowToggle' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Branch out the source Observable values as a nested Observable starting from
 * an emission from `openings` and ending when the output of `closingSelector`
 * emits.
 *
 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowToggle.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows that contain those items
 * emitted by the source Observable between the time when the `openings`
 * Observable emits an item and when the Observable returned by
 * `closingSelector` emits an item.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var result = clicks.windowToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * ).mergeAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowWhen}
 * @see {@link bufferToggle}
 *
 * @param {Observable<O>} openings An observable of notifications to start new
 * windows.
 * @param {function(value: O): Observable} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns an Observable,
 * which, when it emits (either `next` or `complete`), signals that the
 * associated window should complete.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowToggle
 * @owner Observable
 */
export function windowToggle<T, O>(openings: Observable<O>, closingSelector: (openValue: O) => Observable<any>): Observable<Observable<T>>;
export interface WindowToggleSignature<T> {
    <O>(openings: Observable<O>, closingSelector: (openValue: O) => Observable<any>): Observable<Observable<T>>;
}
}
declare module 'rxjs-es/operator/windowToggle' {
export * from '~rxjs-es/operator/windowToggle';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/windowToggle.d.ts
declare module '~rxjs-es/add/operator/windowToggle' {
import { WindowToggleSignature } from '~rxjs-es/operator/windowToggle';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        windowToggle: WindowToggleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/windowWhen.d.ts
declare module '~rxjs-es/operator/windowWhen' {
import { Observable } from '~rxjs-es/Observable';
/**
 * Branch out the source Observable values as a nested Observable using a
 * factory function of closing Observables to determine when to start a new
 * window.
 *
 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowWhen.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping windows.
 * It emits the current window and opens a new one whenever the Observable
 * produced by the specified `closingSelector` function emits an item. The first
 * window is opened immediately when subscribing to the output Observable.
 *
 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks
 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link bufferWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals (on either `next` or
 * `complete`) when to close the previous window and start a new one.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowWhen
 * @owner Observable
 */
export function windowWhen<T>(closingSelector: () => Observable<any>): Observable<Observable<T>>;
export interface WindowWhenSignature<T> {
    (closingSelector: () => Observable<any>): Observable<Observable<T>>;
}
}
declare module 'rxjs-es/operator/windowWhen' {
export * from '~rxjs-es/operator/windowWhen';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/windowWhen.d.ts
declare module '~rxjs-es/add/operator/windowWhen' {
import { WindowWhenSignature } from '~rxjs-es/operator/windowWhen';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        windowWhen: WindowWhenSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/withLatestFrom.d.ts
declare module '~rxjs-es/operator/withLatestFrom' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {Observable} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
export function withLatestFrom<T, R>(...args: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
export interface WithLatestFromSignature<T> {
    <R>(project: (v1: T) => R): Observable<R>;
    <T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;
    <T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
    <T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
    <T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
    <T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
    <T2>(v2: ObservableInput<T2>): Observable<[T, T2]>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
    <R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
    <R>(array: ObservableInput<any>[]): Observable<R>;
    <R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): Observable<R>;
}
}
declare module 'rxjs-es/operator/withLatestFrom' {
export * from '~rxjs-es/operator/withLatestFrom';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/withLatestFrom.d.ts
declare module '~rxjs-es/add/operator/withLatestFrom' {
import { WithLatestFromSignature } from '~rxjs-es/operator/withLatestFrom';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        withLatestFrom: WithLatestFromSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/zip.d.ts
declare module '~rxjs-es/operator/zip' {
import { Observable, ObservableInput } from '~rxjs-es/Observable';
import { Operator } from '~rxjs-es/Operator';
import { Subscriber } from '~rxjs-es/Subscriber';
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
export function zipProto<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
export interface ZipSignature<T> {
    <R>(project: (v1: T) => R): Observable<R>;
    <T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;
    <T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
    <T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
    <T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
    <T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
    <T2>(v2: ObservableInput<T2>): Observable<[T, T2]>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
    <R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;
    <R>(array: Array<ObservableInput<T>>): Observable<R>;
    <TOther, R>(array: Array<ObservableInput<TOther>>, project: (v1: T, ...values: Array<TOther>) => R): Observable<R>;
}
export function zipStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;
export function zipStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
export function zipStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
export function zipStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
export function zipStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
export function zipStatic<T, R>(v1: ObservableInput<T>, project: (v1: T) => R): Observable<R>;
export function zipStatic<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;
export function zipStatic<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
export function zipStatic<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
export function zipStatic<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
export function zipStatic<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
export function zipStatic<T>(array: ObservableInput<T>[]): Observable<T[]>;
export function zipStatic<R>(array: ObservableInput<any>[]): Observable<R>;
export function zipStatic<T, R>(array: ObservableInput<T>[], project: (...values: Array<T>) => R): Observable<R>;
export function zipStatic<R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): Observable<R>;
export function zipStatic<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;
export function zipStatic<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;
export function zipStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
export class ZipOperator<T, R> implements Operator<T, R> {
    project: (...values: Array<any>) => R;
    constructor(project?: (...values: Array<any>) => R);
    call(subscriber: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class ZipSubscriber<T, R> extends Subscriber<T> {
    private index;
    private values;
    private project;
    private iterators;
    private active;
    constructor(destination: Subscriber<R>, project?: (...values: Array<any>) => R, values?: any);
    protected _next(value: any): void;
    protected _complete(): void;
    notifyInactive(): void;
    checkIterators(): void;
    protected _tryProject(args: any[]): void;
}
}
declare module 'rxjs-es/operator/zip' {
export * from '~rxjs-es/operator/zip';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/zip.d.ts
declare module '~rxjs-es/add/operator/zip' {
import { ZipSignature } from '~rxjs-es/operator/zip';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        zip: ZipSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/zipAll.d.ts
declare module '~rxjs-es/operator/zipAll' {
import { Observable } from '~rxjs-es/Observable';
/**
 * @param project
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method zipAll
 * @owner Observable
 */
export function zipAll<T, R>(project?: (...values: Array<any>) => R): Observable<R>;
export interface ZipAllSignature<T> {
    <R>(project?: (...values: Array<T>) => R): Observable<R>;
}
}
declare module 'rxjs-es/operator/zipAll' {
export * from '~rxjs-es/operator/zipAll';
}

// Generated by typings
// Source: node_modules/rxjs-es/add/operator/zipAll.d.ts
declare module '~rxjs-es/add/operator/zipAll' {
import { ZipAllSignature } from '~rxjs-es/operator/zipAll';
module '~rxjs-es/Observable' {
    interface Observable<T> {
        zipAll: ZipAllSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/rxjs-es/Operator.d.ts
declare module '~rxjs-es/Operator' {
import { Subscriber } from '~rxjs-es/Subscriber';
import { TeardownLogic } from '~rxjs-es/Subscription';
export interface Operator<T, R> {
    call(subscriber: Subscriber<R>, source: any): TeardownLogic;
}
}
declare module 'rxjs-es/Operator' {
export * from '~rxjs-es/Operator';
}

// Generated by typings
// Source: node_modules/rxjs-es/Observer.d.ts
declare module '~rxjs-es/Observer' {
export interface NextObserver<T> {
    closed?: boolean;
    next: (value: T) => void;
    error?: (err: any) => void;
    complete?: () => void;
}
export interface ErrorObserver<T> {
    closed?: boolean;
    next?: (value: T) => void;
    error: (err: any) => void;
    complete?: () => void;
}
export interface CompletionObserver<T> {
    closed?: boolean;
    next?: (value: T) => void;
    error?: (err: any) => void;
    complete: () => void;
}
export type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;
export interface Observer<T> {
    closed?: boolean;
    next: (value: T) => void;
    error: (err: any) => void;
    complete: () => void;
}
export const empty: Observer<any>;
}
declare module 'rxjs-es/Observer' {
export * from '~rxjs-es/Observer';
}

// Generated by typings
// Source: node_modules/rxjs-es/Subscription.d.ts
declare module '~rxjs-es/Subscription' {
export interface AnonymousSubscription {
    unsubscribe(): void;
}
export type TeardownLogic = AnonymousSubscription | Function | void;
export interface ISubscription extends AnonymousSubscription {
    unsubscribe(): void;
    closed: boolean;
}
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
export class Subscription implements ISubscription {
    static EMPTY: Subscription;
    /**
     * A flag to indicate whether this Subscription has already been unsubscribed.
     * @type {boolean}
     */
    closed: boolean;
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    constructor(unsubscribe?: () => void);
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    unsubscribe(): void;
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    add(teardown: TeardownLogic): Subscription;
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    remove(subscription: Subscription): void;
}
}
declare module 'rxjs-es/Subscription' {
export * from '~rxjs-es/Subscription';
}

// Generated by typings
// Source: node_modules/rxjs-es/Subscriber.d.ts
declare module '~rxjs-es/Subscriber' {
import { Observer, PartialObserver } from '~rxjs-es/Observer';
import { Subscription } from '~rxjs-es/Subscription';
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
export class Subscriber<T> extends Subscription implements Observer<T> {
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T>;
    syncErrorValue: any;
    syncErrorThrown: boolean;
    syncErrorThrowable: boolean;
    protected isStopped: boolean;
    protected destination: PartialObserver<any>;
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    next(value?: T): void;
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    error(err?: any): void;
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    complete(): void;
    unsubscribe(): void;
    protected _next(value: T): void;
    protected _error(err: any): void;
    protected _complete(): void;
}
}
declare module 'rxjs-es/Subscriber' {
export * from '~rxjs-es/Subscriber';
}

// Generated by typings
// Source: node_modules/rxjs-es/AsyncSubject.d.ts
declare module '~rxjs-es/AsyncSubject' {
import { Subject } from '~rxjs-es/Subject';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
/**
 * @class AsyncSubject<T>
 */
export class AsyncSubject<T> extends Subject<T> {
    private value;
    private hasNext;
    private hasCompleted;
    protected _subscribe(subscriber: Subscriber<any>): Subscription;
    next(value: T): void;
    complete(): void;
}
}
declare module 'rxjs-es/AsyncSubject' {
export * from '~rxjs-es/AsyncSubject';
}

// Generated by typings
// Source: node_modules/rxjs-es/scheduler/Action.d.ts
declare module '~rxjs-es/scheduler/Action' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { Subscription } from '~rxjs-es/Subscription';
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
export class Action<T> extends Subscription {
    constructor(scheduler: Scheduler, work: (state?: T) => void);
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    schedule(state?: T, delay?: number): Subscription;
}
}
declare module 'rxjs-es/scheduler/Action' {
export * from '~rxjs-es/scheduler/Action';
}

// Generated by typings
// Source: node_modules/rxjs-es/Scheduler.d.ts
declare module '~rxjs-es/Scheduler' {
import { Action } from '~rxjs-es/scheduler/Action';
import { Subscription } from '~rxjs-es/Subscription';
/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
export class Scheduler {
    private SchedulerAction;
    static now: () => number;
    constructor(SchedulerAction: typeof Action, now?: () => number);
    /**
     * A getter method that returns a number representing the current time
     * (at the time this function was called) according to the scheduler's own
     * internal clock.
     * @return {number} A number that represents the current time. May or may not
     * have a relation to wall-clock time. May or may not refer to a time unit
     * (e.g. milliseconds).
     */
    now: () => number;
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    schedule<T>(work: (state?: T) => void, delay?: number, state?: T): Subscription;
}
}
declare module 'rxjs-es/Scheduler' {
export * from '~rxjs-es/Scheduler';
}

// Generated by typings
// Source: node_modules/rxjs-es/ReplaySubject.d.ts
declare module '~rxjs-es/ReplaySubject' {
import { Subject } from '~rxjs-es/Subject';
import { Scheduler } from '~rxjs-es/Scheduler';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
/**
 * @class ReplaySubject<T>
 */
export class ReplaySubject<T> extends Subject<T> {
    private scheduler;
    private _events;
    private _bufferSize;
    private _windowTime;
    constructor(bufferSize?: number, windowTime?: number, scheduler?: Scheduler);
    next(value: T): void;
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
    _getNow(): number;
    private _trimBufferThenGetEvents();
}
}
declare module 'rxjs-es/ReplaySubject' {
export * from '~rxjs-es/ReplaySubject';
}

// Generated by typings
// Source: node_modules/rxjs-es/BehaviorSubject.d.ts
declare module '~rxjs-es/BehaviorSubject' {
import { Subject } from '~rxjs-es/Subject';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
/**
 * @class BehaviorSubject<T>
 */
export class BehaviorSubject<T> extends Subject<T> {
    private _value;
    constructor(_value: T);
    value: T;
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
    getValue(): T;
    next(value: T): void;
}
}
declare module 'rxjs-es/BehaviorSubject' {
export * from '~rxjs-es/BehaviorSubject';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/MulticastObservable.d.ts
declare module '~rxjs-es/observable/MulticastObservable' {
import { Subject } from '~rxjs-es/Subject';
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
export class MulticastObservable<T> extends Observable<T> {
    protected source: Observable<T>;
    private subjectFactory;
    private selector;
    constructor(source: Observable<T>, subjectFactory: () => Subject<T>, selector: (source: Observable<T>) => Observable<T>);
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
}
}
declare module 'rxjs-es/observable/MulticastObservable' {
export * from '~rxjs-es/observable/MulticastObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/ConnectableObservable.d.ts
declare module '~rxjs-es/observable/ConnectableObservable' {
import { Subject } from '~rxjs-es/Subject';
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { Subscription } from '~rxjs-es/Subscription';
/**
 * @class ConnectableObservable<T>
 */
export class ConnectableObservable<T> extends Observable<T> {
    protected source: Observable<T>;
    protected subjectFactory: () => Subject<T>;
    protected _subject: Subject<T>;
    protected _refCount: number;
    protected _connection: Subscription;
    constructor(source: Observable<T>, subjectFactory: () => Subject<T>);
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
    protected getSubject(): Subject<T>;
    connect(): Subscription;
    refCount(): Observable<T>;
}
}
declare module 'rxjs-es/observable/ConnectableObservable' {
export * from '~rxjs-es/observable/ConnectableObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/Notification.d.ts
declare module '~rxjs-es/Notification' {
import { PartialObserver } from '~rxjs-es/Observer';
import { Observable } from '~rxjs-es/Observable';
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
export class Notification<T> {
    kind: string;
    value: T;
    exception: any;
    hasValue: boolean;
    constructor(kind: string, value?: T, exception?: any);
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    observe(observer: PartialObserver<T>): any;
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any;
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void): any;
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    toObservable(): Observable<T>;
    private static completeNotification;
    private static undefinedValueNotification;
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    static createNext<T>(value: T): Notification<T>;
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` exception.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    static createError<T>(err?: any): Notification<T>;
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    static createComplete(): Notification<any>;
}
}
declare module 'rxjs-es/Notification' {
export * from '~rxjs-es/Notification';
}

// Generated by typings
// Source: node_modules/rxjs-es/util/EmptyError.d.ts
declare module '~rxjs-es/util/EmptyError' {
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
export class EmptyError extends Error {
    constructor();
}
}
declare module 'rxjs-es/util/EmptyError' {
export * from '~rxjs-es/util/EmptyError';
}

// Generated by typings
// Source: node_modules/rxjs-es/util/ArgumentOutOfRangeError.d.ts
declare module '~rxjs-es/util/ArgumentOutOfRangeError' {
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
export class ArgumentOutOfRangeError extends Error {
    constructor();
}
}
declare module 'rxjs-es/util/ArgumentOutOfRangeError' {
export * from '~rxjs-es/util/ArgumentOutOfRangeError';
}

// Generated by typings
// Source: node_modules/rxjs-es/util/ObjectUnsubscribedError.d.ts
declare module '~rxjs-es/util/ObjectUnsubscribedError' {
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
export class ObjectUnsubscribedError extends Error {
    constructor();
}
}
declare module 'rxjs-es/util/ObjectUnsubscribedError' {
export * from '~rxjs-es/util/ObjectUnsubscribedError';
}

// Generated by typings
// Source: node_modules/rxjs-es/util/UnsubscriptionError.d.ts
declare module '~rxjs-es/util/UnsubscriptionError' {
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
export class UnsubscriptionError extends Error {
    errors: any[];
    constructor(errors: any[]);
}
}
declare module 'rxjs-es/util/UnsubscriptionError' {
export * from '~rxjs-es/util/UnsubscriptionError';
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/timeInterval.d.ts
declare module '~rxjs-es/operator/timeInterval' {
import { Observable } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
/**
 * @param scheduler
 * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}
 * @method timeInterval
 * @owner Observable
 */
export function timeInterval<T>(scheduler?: Scheduler): Observable<TimeInterval<T>>;
export interface TimeIntervalSignature<T> {
    (scheduler?: Scheduler): Observable<TimeInterval<T>>;
}
export class TimeInterval<T> {
    value: T;
    interval: number;
    constructor(value: T, interval: number);
}
}
declare module 'rxjs-es/operator/timeInterval' {
export * from '~rxjs-es/operator/timeInterval';
}

// Generated by typings
// Source: node_modules/rxjs-es/operator/timestamp.d.ts
declare module '~rxjs-es/operator/timestamp' {
import { Observable } from '~rxjs-es/Observable';
import { Scheduler } from '~rxjs-es/Scheduler';
/**
 * @param scheduler
 * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
 * @method timestamp
 * @owner Observable
 */
export function timestamp<T>(scheduler?: Scheduler): Observable<Timestamp<T>>;
export interface TimestampSignature<T> {
    (scheduler?: Scheduler): Observable<Timestamp<T>>;
}
export class Timestamp<T> {
    value: T;
    timestamp: number;
    constructor(value: T, timestamp: number);
}
}
declare module 'rxjs-es/operator/timestamp' {
export * from '~rxjs-es/operator/timestamp';
}

// Generated by typings
// Source: node_modules/rxjs-es/testing/TestMessage.d.ts
declare module '~rxjs-es/testing/TestMessage' {
import { Notification } from '~rxjs-es/Notification';
export interface TestMessage {
    frame: number;
    notification: Notification<any>;
}
}
declare module 'rxjs-es/testing/TestMessage' {
export * from '~rxjs-es/testing/TestMessage';
}

// Generated by typings
// Source: node_modules/rxjs-es/testing/SubscriptionLog.d.ts
declare module '~rxjs-es/testing/SubscriptionLog' {
export class SubscriptionLog {
    subscribedFrame: number;
    unsubscribedFrame: number;
    constructor(subscribedFrame: number, unsubscribedFrame?: number);
}
}
declare module 'rxjs-es/testing/SubscriptionLog' {
export * from '~rxjs-es/testing/SubscriptionLog';
}

// Generated by typings
// Source: node_modules/rxjs-es/testing/TestScheduler.d.ts
declare module '~rxjs-es/testing/TestScheduler' {
import { Observable } from '~rxjs-es/Observable';
import { Subject } from '~rxjs-es/Subject';
import { TestMessage } from '~rxjs-es/testing/TestMessage';
import { SubscriptionLog } from '~rxjs-es/testing/SubscriptionLog';
import { VirtualTimeScheduler } from '~rxjs-es/scheduler/VirtualTimeScheduler';
export type observableToBeFn = (marbles: string, values?: any, errorValue?: any) => void;
export type subscriptionLogsToBeFn = (marbles: string | string[]) => void;
export class TestScheduler extends VirtualTimeScheduler {
    assertDeepEqual: (actual: any, expected: any) => boolean | void;
    private hotObservables;
    private coldObservables;
    private flushTests;
    constructor(assertDeepEqual: (actual: any, expected: any) => boolean | void);
    createTime(marbles: string): number;
    createColdObservable<T>(marbles: string, values?: any, error?: any): Observable<T>;
    createHotObservable<T>(marbles: string, values?: any, error?: any): Subject<T>;
    private materializeInnerObservable(observable, outerFrame);
    expectObservable(observable: Observable<any>, unsubscriptionMarbles?: string): ({
        toBe: observableToBeFn;
    });
    expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]): ({
        toBe: subscriptionLogsToBeFn;
    });
    flush(): void;
    static parseMarblesAsSubscriptions(marbles: string): SubscriptionLog;
    static parseMarbles(marbles: string, values?: any, errorValue?: any, materializeInnerObservables?: boolean): TestMessage[];
}
}
declare module 'rxjs-es/testing/TestScheduler' {
export * from '~rxjs-es/testing/TestScheduler';
}

// Generated by typings
// Source: node_modules/rxjs-es/scheduler/AsyncAction.d.ts
declare module '~rxjs-es/scheduler/AsyncAction' {
import { Action } from '~rxjs-es/scheduler/Action';
import { Subscription } from '~rxjs-es/Subscription';
import { AsyncScheduler } from '~rxjs-es/scheduler/AsyncScheduler';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class AsyncAction<T> extends Action<T> {
    protected scheduler: AsyncScheduler;
    protected work: (state?: T) => void;
    id: any;
    state: T;
    delay: number;
    protected pending: boolean;
    constructor(scheduler: AsyncScheduler, work: (state?: T) => void);
    schedule(state?: T, delay?: number): Subscription;
    protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay?: number): any;
    protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay?: number): any;
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    execute(state: T, delay: number): any;
    protected _execute(state: T, delay: number): any;
    protected _unsubscribe(): void;
}
}
declare module 'rxjs-es/scheduler/AsyncAction' {
export * from '~rxjs-es/scheduler/AsyncAction';
}

// Generated by typings
// Source: node_modules/rxjs-es/scheduler/VirtualTimeScheduler.d.ts
declare module '~rxjs-es/scheduler/VirtualTimeScheduler' {
import { AsyncAction } from '~rxjs-es/scheduler/AsyncAction';
import { Subscription } from '~rxjs-es/Subscription';
import { AsyncScheduler } from '~rxjs-es/scheduler/AsyncScheduler';
export class VirtualTimeScheduler extends AsyncScheduler {
    maxFrames: number;
    protected static frameTimeFactor: number;
    frame: number;
    index: number;
    constructor(SchedulerAction?: typeof AsyncAction, maxFrames?: number);
    /**
     * Prompt the Scheduler to execute all of its queued actions, therefore
     * clearing its queue.
     * @return {void}
     */
    flush(): void;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class VirtualAction<T> extends AsyncAction<T> {
    protected scheduler: VirtualTimeScheduler;
    protected work: (state?: T) => void;
    protected index: number;
    constructor(scheduler: VirtualTimeScheduler, work: (state?: T) => void, index?: number);
    schedule(state?: T, delay?: number): Subscription;
    protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;
    protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;
    static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>): number;
}
}
declare module 'rxjs-es/scheduler/VirtualTimeScheduler' {
export * from '~rxjs-es/scheduler/VirtualTimeScheduler';
}

// Generated by typings
// Source: node_modules/rxjs-es/observable/dom/AjaxObservable.d.ts
declare module '~rxjs-es/observable/dom/AjaxObservable' {
import { Observable } from '~rxjs-es/Observable';
import { Subscriber } from '~rxjs-es/Subscriber';
import { TeardownLogic } from '~rxjs-es/Subscription';
export interface AjaxRequest {
    url?: string;
    body?: any;
    user?: string;
    async?: boolean;
    method?: string;
    headers?: Object;
    timeout?: number;
    password?: string;
    hasContent?: boolean;
    crossDomain?: boolean;
    withCredentials?: boolean;
    createXHR?: () => XMLHttpRequest;
    progressSubscriber?: Subscriber<any>;
    responseType?: string;
}
export interface AjaxCreationMethod {
    (urlOrRequest: string | AjaxRequest): Observable<AjaxResponse>;
    get(url: string, headers?: Object): Observable<AjaxResponse>;
    post(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;
    put(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;
    delete(url: string, headers?: Object): Observable<AjaxResponse>;
    getJSON<T, R>(url: string, headers?: Object): Observable<R>;
}
export function ajaxGet(url: string, headers?: Object): AjaxObservable<AjaxResponse>;
export function ajaxPost(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;
export function ajaxDelete(url: string, headers?: Object): Observable<AjaxResponse>;
export function ajaxPut(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;
export function ajaxGetJSON<T>(url: string, headers?: Object): Observable<T>;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class AjaxObservable<T> extends Observable<T> {
    /**
     * Creates an observable for an Ajax request with either a request object with
     * url, headers, etc or a string for a URL.
     *
     * @example
     * source = Rx.Observable.ajax('/products');
     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
     *
     * @param {string|Object} request Can be one of the following:
     *   A string of the URL to make the Ajax call.
     *   An object with the following properties
     *   - url: URL of the request
     *   - body: The body of the request
     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
     *   - async: Whether the request is async
     *   - headers: Optional headers
     *   - crossDomain: true if a cross domain request, else false
     *   - createXHR: a function to override if you need to use an alternate
     *   XMLHttpRequest implementation.
     *   - resultSelector: a function to use to alter the output value type of
     *   the Observable. Gets {@link AjaxResponse} as an argument.
     * @return {Observable} An observable sequence containing the XMLHttpRequest.
     * @static true
     * @name ajax
     * @owner Observable
    */
    static create: AjaxCreationMethod;
    private request;
    constructor(urlOrRequest: string | AjaxRequest);
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class AjaxSubscriber<T> extends Subscriber<Event> {
    request: AjaxRequest;
    private xhr;
    private done;
    constructor(destination: Subscriber<T>, request: AjaxRequest);
    next(e: Event): void;
    private send();
    private serializeBody(body, contentType?);
    private setHeaders(xhr, headers);
    private setupEvents(xhr, request);
    unsubscribe(): void;
}
/**
 * A normalized AJAX response.
 *
 * @see {@link ajax}
 *
 * @class AjaxResponse
 */
export class AjaxResponse {
    originalEvent: Event;
    xhr: XMLHttpRequest;
    request: AjaxRequest;
    /** @type {number} The HTTP status code */
    status: number;
    /** @type {string|ArrayBuffer|Document|object|any} The response data */
    response: any;
    /** @type {string} The raw responseText */
    responseText: string;
    /** @type {string} The responseType (e.g. 'json', 'arraybuffer', or 'xml') */
    responseType: string;
    constructor(originalEvent: Event, xhr: XMLHttpRequest, request: AjaxRequest);
}
/**
 * A normalized AJAX error.
 *
 * @see {@link ajax}
 *
 * @class AjaxError
 */
export class AjaxError extends Error {
    /** @type {XMLHttpRequest} The XHR instance associated with the error */
    xhr: XMLHttpRequest;
    /** @type {AjaxRequest} The AjaxRequest associated with the error */
    request: AjaxRequest;
    /** @type {number} The HTTP status code */
    status: number;
    constructor(message: string, xhr: XMLHttpRequest, request: AjaxRequest);
}
/**
 * @see {@link ajax}
 *
 * @class AjaxTimeoutError
 */
export class AjaxTimeoutError extends AjaxError {
    constructor(xhr: XMLHttpRequest, request: AjaxRequest);
}
}
declare module 'rxjs-es/observable/dom/AjaxObservable' {
export * from '~rxjs-es/observable/dom/AjaxObservable';
}

// Generated by typings
// Source: node_modules/rxjs-es/scheduler/AsapScheduler.d.ts
declare module '~rxjs-es/scheduler/AsapScheduler' {
import { AsyncScheduler } from '~rxjs-es/scheduler/AsyncScheduler';
export class AsapScheduler extends AsyncScheduler {
    flush(): void;
}
}
declare module 'rxjs-es/scheduler/AsapScheduler' {
export * from '~rxjs-es/scheduler/AsapScheduler';
}

// Generated by typings
// Source: node_modules/rxjs-es/scheduler/AsyncScheduler.d.ts
declare module '~rxjs-es/scheduler/AsyncScheduler' {
import { Scheduler } from '~rxjs-es/Scheduler';
import { AsyncAction } from '~rxjs-es/scheduler/AsyncAction';
export class AsyncScheduler extends Scheduler {
    actions: Array<AsyncAction<any>>;
    /**
     * A flag to indicate whether the Scheduler is currently executing a batch of
     * queued actions.
     * @type {boolean}
     */
    active: boolean;
    /**
     * An internal ID used to track the latest asynchronous task such as those
     * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
     * others.
     * @type {any}
     */
    scheduled: any;
    flush(action: AsyncAction<any>): void;
}
}
declare module 'rxjs-es/scheduler/AsyncScheduler' {
export * from '~rxjs-es/scheduler/AsyncScheduler';
}

// Generated by typings
// Source: node_modules/rxjs-es/scheduler/QueueScheduler.d.ts
declare module '~rxjs-es/scheduler/QueueScheduler' {
import { AsyncScheduler } from '~rxjs-es/scheduler/AsyncScheduler';
export class QueueScheduler extends AsyncScheduler {
}
}
declare module 'rxjs-es/scheduler/QueueScheduler' {
export * from '~rxjs-es/scheduler/QueueScheduler';
}

// Generated by typings
// Source: node_modules/rxjs-es/scheduler/AnimationFrameScheduler.d.ts
declare module '~rxjs-es/scheduler/AnimationFrameScheduler' {
import { AsyncScheduler } from '~rxjs-es/scheduler/AsyncScheduler';
export class AnimationFrameScheduler extends AsyncScheduler {
    flush(): void;
}
}
declare module 'rxjs-es/scheduler/AnimationFrameScheduler' {
export * from '~rxjs-es/scheduler/AnimationFrameScheduler';
}

// Generated by typings
// Source: node_modules/rxjs-es/Rx.d.ts
declare module '~rxjs-es/Rx' {
export { Subject } from '~rxjs-es/Subject';
export { Observable } from '~rxjs-es/Observable';
import '~rxjs-es/add/observable/bindCallback';
import '~rxjs-es/add/observable/bindNodeCallback';
import '~rxjs-es/add/observable/combineLatest';
import '~rxjs-es/add/observable/concat';
import '~rxjs-es/add/observable/defer';
import '~rxjs-es/add/observable/empty';
import '~rxjs-es/add/observable/forkJoin';
import '~rxjs-es/add/observable/from';
import '~rxjs-es/add/observable/fromEvent';
import '~rxjs-es/add/observable/fromEventPattern';
import '~rxjs-es/add/observable/fromPromise';
import '~rxjs-es/add/observable/generate';
import '~rxjs-es/add/observable/if';
import '~rxjs-es/add/observable/interval';
import '~rxjs-es/add/observable/merge';
import '~rxjs-es/add/observable/race';
import '~rxjs-es/add/observable/never';
import '~rxjs-es/add/observable/of';
import '~rxjs-es/add/observable/onErrorResumeNext';
import '~rxjs-es/add/observable/pairs';
import '~rxjs-es/add/observable/range';
import '~rxjs-es/add/observable/using';
import '~rxjs-es/add/observable/throw';
import '~rxjs-es/add/observable/timer';
import '~rxjs-es/add/observable/zip';
import '~rxjs-es/add/observable/dom/ajax';
import '~rxjs-es/add/observable/dom/webSocket';
import '~rxjs-es/add/operator/buffer';
import '~rxjs-es/add/operator/bufferCount';
import '~rxjs-es/add/operator/bufferTime';
import '~rxjs-es/add/operator/bufferToggle';
import '~rxjs-es/add/operator/bufferWhen';
import '~rxjs-es/add/operator/cache';
import '~rxjs-es/add/operator/catch';
import '~rxjs-es/add/operator/combineAll';
import '~rxjs-es/add/operator/combineLatest';
import '~rxjs-es/add/operator/concat';
import '~rxjs-es/add/operator/concatAll';
import '~rxjs-es/add/operator/concatMap';
import '~rxjs-es/add/operator/concatMapTo';
import '~rxjs-es/add/operator/count';
import '~rxjs-es/add/operator/dematerialize';
import '~rxjs-es/add/operator/debounce';
import '~rxjs-es/add/operator/debounceTime';
import '~rxjs-es/add/operator/defaultIfEmpty';
import '~rxjs-es/add/operator/delay';
import '~rxjs-es/add/operator/delayWhen';
import '~rxjs-es/add/operator/distinct';
import '~rxjs-es/add/operator/distinctKey';
import '~rxjs-es/add/operator/distinctUntilChanged';
import '~rxjs-es/add/operator/distinctUntilKeyChanged';
import '~rxjs-es/add/operator/do';
import '~rxjs-es/add/operator/exhaust';
import '~rxjs-es/add/operator/exhaustMap';
import '~rxjs-es/add/operator/expand';
import '~rxjs-es/add/operator/elementAt';
import '~rxjs-es/add/operator/filter';
import '~rxjs-es/add/operator/finally';
import '~rxjs-es/add/operator/find';
import '~rxjs-es/add/operator/findIndex';
import '~rxjs-es/add/operator/first';
import '~rxjs-es/add/operator/groupBy';
import '~rxjs-es/add/operator/ignoreElements';
import '~rxjs-es/add/operator/isEmpty';
import '~rxjs-es/add/operator/audit';
import '~rxjs-es/add/operator/auditTime';
import '~rxjs-es/add/operator/last';
import '~rxjs-es/add/operator/let';
import '~rxjs-es/add/operator/every';
import '~rxjs-es/add/operator/map';
import '~rxjs-es/add/operator/mapTo';
import '~rxjs-es/add/operator/materialize';
import '~rxjs-es/add/operator/max';
import '~rxjs-es/add/operator/merge';
import '~rxjs-es/add/operator/mergeAll';
import '~rxjs-es/add/operator/mergeMap';
import '~rxjs-es/add/operator/mergeMapTo';
import '~rxjs-es/add/operator/mergeScan';
import '~rxjs-es/add/operator/min';
import '~rxjs-es/add/operator/multicast';
import '~rxjs-es/add/operator/observeOn';
import '~rxjs-es/add/operator/onErrorResumeNext';
import '~rxjs-es/add/operator/pairwise';
import '~rxjs-es/add/operator/partition';
import '~rxjs-es/add/operator/pluck';
import '~rxjs-es/add/operator/publish';
import '~rxjs-es/add/operator/publishBehavior';
import '~rxjs-es/add/operator/publishReplay';
import '~rxjs-es/add/operator/publishLast';
import '~rxjs-es/add/operator/race';
import '~rxjs-es/add/operator/reduce';
import '~rxjs-es/add/operator/repeat';
import '~rxjs-es/add/operator/repeatWhen';
import '~rxjs-es/add/operator/retry';
import '~rxjs-es/add/operator/retryWhen';
import '~rxjs-es/add/operator/sample';
import '~rxjs-es/add/operator/sampleTime';
import '~rxjs-es/add/operator/scan';
import '~rxjs-es/add/operator/sequenceEqual';
import '~rxjs-es/add/operator/share';
import '~rxjs-es/add/operator/single';
import '~rxjs-es/add/operator/skip';
import '~rxjs-es/add/operator/skipUntil';
import '~rxjs-es/add/operator/skipWhile';
import '~rxjs-es/add/operator/startWith';
import '~rxjs-es/add/operator/subscribeOn';
import '~rxjs-es/add/operator/switch';
import '~rxjs-es/add/operator/switchMap';
import '~rxjs-es/add/operator/switchMapTo';
import '~rxjs-es/add/operator/take';
import '~rxjs-es/add/operator/takeLast';
import '~rxjs-es/add/operator/takeUntil';
import '~rxjs-es/add/operator/takeWhile';
import '~rxjs-es/add/operator/throttle';
import '~rxjs-es/add/operator/throttleTime';
import '~rxjs-es/add/operator/timeInterval';
import '~rxjs-es/add/operator/timeout';
import '~rxjs-es/add/operator/timeoutWith';
import '~rxjs-es/add/operator/timestamp';
import '~rxjs-es/add/operator/toArray';
import '~rxjs-es/add/operator/toPromise';
import '~rxjs-es/add/operator/window';
import '~rxjs-es/add/operator/windowCount';
import '~rxjs-es/add/operator/windowTime';
import '~rxjs-es/add/operator/windowToggle';
import '~rxjs-es/add/operator/windowWhen';
import '~rxjs-es/add/operator/withLatestFrom';
import '~rxjs-es/add/operator/zip';
import '~rxjs-es/add/operator/zipAll';
export { Operator } from '~rxjs-es/Operator';
export { Observer } from '~rxjs-es/Observer';
export { Subscription } from '~rxjs-es/Subscription';
export { Subscriber } from '~rxjs-es/Subscriber';
export { AsyncSubject } from '~rxjs-es/AsyncSubject';
export { ReplaySubject } from '~rxjs-es/ReplaySubject';
export { BehaviorSubject } from '~rxjs-es/BehaviorSubject';
export { MulticastObservable } from '~rxjs-es/observable/MulticastObservable';
export { ConnectableObservable } from '~rxjs-es/observable/ConnectableObservable';
export { Notification } from '~rxjs-es/Notification';
export { EmptyError } from '~rxjs-es/util/EmptyError';
export { ArgumentOutOfRangeError } from '~rxjs-es/util/ArgumentOutOfRangeError';
export { ObjectUnsubscribedError } from '~rxjs-es/util/ObjectUnsubscribedError';
export { UnsubscriptionError } from '~rxjs-es/util/UnsubscriptionError';
export { TimeInterval } from '~rxjs-es/operator/timeInterval';
export { Timestamp } from '~rxjs-es/operator/timestamp';
export { TestScheduler } from '~rxjs-es/testing/TestScheduler';
export { VirtualTimeScheduler } from '~rxjs-es/scheduler/VirtualTimeScheduler';
export { AjaxRequest, AjaxResponse, AjaxError, AjaxTimeoutError } from '~rxjs-es/observable/dom/AjaxObservable';
import { AsapScheduler } from '~rxjs-es/scheduler/AsapScheduler';
import { AsyncScheduler } from '~rxjs-es/scheduler/AsyncScheduler';
import { QueueScheduler } from '~rxjs-es/scheduler/QueueScheduler';
import { AnimationFrameScheduler } from '~rxjs-es/scheduler/AnimationFrameScheduler';
/**
 * @typedef {Object} Rx.Scheduler
 * @property {Scheduler} queue Schedules on a queue in the current event frame
 * (trampoline scheduler). Use this for iteration operations.
 * @property {Scheduler} asap Schedules on the micro task queue, which uses the
 * fastest transport mechanism available, either Node.js' `process.nextTick()`
 * or Web Worker MessageChannel or setTimeout or others. Use this for
 * asynchronous conversions.
 * @property {Scheduler} async Schedules work with `setInterval`. Use this for
 * time-based operations.
 * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.
 * Use this for synchronizing with the platform's painting
 */
let Scheduler: {
    asap: AsapScheduler;
    queue: QueueScheduler;
    animationFrame: AnimationFrameScheduler;
    async: AsyncScheduler;
};
/**
 * @typedef {Object} Rx.Symbol
 * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
 * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
 * an object that has all of the traits of an Rx Subscriber, including the
 * ability to add and remove subscriptions to the subscription chain and
 * guarantees involving event triggering (can't "next" after unsubscription,
 * etc).
 * @property {Symbol|string} observable A symbol to use as a property name to
 * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
 * @property {Symbol|string} iterator The ES6 symbol to use as a property name
 * to retrieve an iterator from an object.
 */
let Symbol: {
    rxSubscriber: any;
    observable: any;
    iterator: any;
};
export { Scheduler, Symbol };
}
declare module 'rxjs-es/Rx' {
export * from '~rxjs-es/Rx';
}
declare module 'rxjs-es' {
export * from '~rxjs-es/Rx';
}
